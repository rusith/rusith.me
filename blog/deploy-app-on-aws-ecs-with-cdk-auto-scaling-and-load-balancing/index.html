<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><link href="https://gmpg.org/xfn/11" rel="profile"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-5GDZWWBRFX"></script><script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());
                gtag('config', 'G-5GDZWWBRFX');
                </script><link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://rusith.me/icons/favicon-144-image.png"/><link rel="shortcut icon" href="https://rusith.me/favicon.ico"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/><meta property="twitter:creator" content="@rusith_"/><meta name="robots" content="index,follow"/><title>Deploying an app on AWS ECS with CDK</title><meta name="description" content="How to deploy an application on AWS ECS with load-balancing and auto-scaling using CDK by writing the CDK code in TypeScript"/><link rel="canonical" href="https://rusith.me/blog/deploy-app-on-aws-ecs-with-cdk-auto-scaling-and-load-balancing"/><meta property="og:title" content="Deploying an app on AWS ECS with CDK"/><meta property="og:url" content="https://rusith.me/blog/deploy-app-on-aws-ecs-with-cdk-auto-scaling-and-load-balancing"/><meta property="og:description" content="How to deploy an application on AWS ECS with load-balancing and auto-scaling using CDK by writing the CDK code in TypeScript"/><meta property="og:site_name" content="Rusith&#x27;s blog"/><meta property="og:locale" content="en_US"/><meta property="og:type" content="blog"/><meta property="twitter:description" content="How to deploy an application on AWS ECS with load-balancing and auto-scaling using CDK by writing the CDK code in TypeScript"/><meta property="og:image" content="/post-data/2023-02-15-deploying-react-app-on-ecs/banner.png"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Deploying an app on AWS ECS with CDK"/><meta name="twitter:image" content="/post-data/2023-02-15-deploying-react-app-on-ecs/banner.png"/><meta name="twitter:site" content="@rusith_"/><script type="application/ld+json">{"@type":"BlogPosting","@context":"https://schema.org","headline":"Deploying an app on AWS ECS with CDK","author":{"@type":"Person","name":"Shanaka Rusith","url":"https://rusith.me/about"},"keywords":"programming,nextJS,react,aws,ecs,typescript,cdk,devops","url":"https://rusith.me/blog/deploy-app-on-aws-ecs-with-cdk-auto-scaling-and-load-balancing","description":"How to deploy an application on AWS ECS with load-balancing and auto-scaling using CDK by writing the CDK code in TypeScript","copyrightHolder":{"@type":"Person","name":"Shanaka Rusith","url":"https://rusith.me/about"},"copyrightYear":"2021","mainEntityOfPage":{"@type":"WebPage","@id":"https://rusith.me"},"publisher":{"@type":"Organization","name":"Shanaka Rusith","url":"https://rusith.me/about","logo":{"@type":"ImageObject","url":"https://rusith.me/images/rusith/picture.jpg"}},"image":"/post-data/2023-02-15-deploying-react-app-on-ecs/banner.png","about":"How to deploy an application on AWS ECS with load-balancing and auto-scaling using CDK by writing the CDK code in TypeScript","datePublished":"Wed Feb 15 2023 00:00:00 GMT+0000 (Coordinated Universal Time)","dateModified":"Wed Feb 15 2023 00:00:00 GMT+0000 (Coordinated Universal Time)"}</script><meta name="next-head-count" content="27"/><link rel="preload" href="/_next/static/css/7220332d6168fb06.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7220332d6168fb06.css" data-n-g=""/><link rel="preload" href="/_next/static/css/0662676664ee362f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0662676664ee362f.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-05c0aa1e498fcb8c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f89480c30d9a5d02.js" defer=""></script><script src="/_next/static/chunks/947-277c090e7d6803d0.js" defer=""></script><script src="/_next/static/chunks/pages/%5B%5B...path%5D%5D-d5cf2aa81a49e144.js" defer=""></script><script src="/_next/static/PaoTT2YDvwYY_jbobaNoC/_buildManifest.js" defer=""></script><script src="/_next/static/PaoTT2YDvwYY_jbobaNoC/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="Sidebar_r__IEuUi"><div class="Sidebar_sticky__RE23V"><div class="Sidebar_about__s_kM6"><h2><a href="/">Rusith.me</a></h2><div class="Sidebar_socialButtons__XcH6p"><a href="https://www.linkedin.com/in/shanaka-rusith" class="Sidebar_socialButton___U_F2" target="_blank" rel="noreferrer"><img alt="LinkedIn icon" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA0NDggNTEyIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0NDggNTEyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6I0ZGRkZGRjt9Cjwvc3R5bGU+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MTYsMzJIMzEuOUMxNC4zLDMyLDAsNDYuNSwwLDY0LjN2MzgzLjRDMCw0NjUuNSwxNC4zLDQ4MCwzMS45LDQ4MEg0MTZjMTcuNiwwLDMyLTE0LjUsMzItMzIuM1Y2NC4zCglDNDQ4LDQ2LjUsNDMzLjYsMzIsNDE2LDMyeiBNMTM1LjQsNDE2SDY5VjIwMi4yaDY2LjVWNDE2SDEzNS40eiBNMTAyLjIsMTczYy0yMS4zLDAtMzguNS0xNy4zLTM4LjUtMzguNVM4MC45LDk2LDEwMi4yLDk2CgljMjEuMiwwLDM4LjUsMTcuMywzOC41LDM4LjVDMTQwLjcsMTU1LjgsMTIzLjUsMTczLDEwMi4yLDE3M3ogTTM4NC4zLDQxNmgtNjYuNFYzMTJjMC0yNC44LTAuNS01Ni43LTM0LjUtNTYuNwoJYy0zNC42LDAtMzkuOSwyNy0zOS45LDU0LjlWNDE2aC02Ni40VjIwMi4yaDYzLjd2MjkuMmgwLjljOC45LTE2LjgsMzAuNi0zNC41LDYyLjktMzQuNWM2Ny4yLDAsNzkuNyw0NC4zLDc5LjcsMTAxLjlWNDE2eiIvPgo8L3N2Zz4K"/></a><a href="https://github.com/rusith" class="Sidebar_socialButton___U_F2" target="_blank" rel="noreferrer"><img alt="Github icon" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA0NDggNTEyIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0NDggNTEyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6I0ZGRkZGRjt9Cjwvc3R5bGU+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MDAsMzJINDhDMjEuNSwzMiwwLDUzLjUsMCw4MHYzNTJjMCwyNi41LDIxLjUsNDgsNDgsNDhoMzUyYzI2LjUsMCw0OC0yMS41LDQ4LTQ4VjgwCglDNDQ4LDUzLjUsNDI2LjUsMzIsNDAwLDMyeiBNMjc3LjMsNDE1LjdjLTguNCwxLjUtMTEuNS0zLjctMTEuNS04YzAtNS40LDAuMi0zMywwLjItNTUuM2MwLTE1LjYtNS4yLTI1LjUtMTEuMy0zMC43CgljMzctNC4xLDc2LTkuMiw3Ni03My4xYzAtMTguMi02LjUtMjcuMy0xNy4xLTM5YzEuNy00LjMsNy40LTIyLTEuNy00NWMtMTMuOS00LjMtNDUuNywxNy45LTQ1LjcsMTcuOWMtMTMuMi0zLjctMjcuNS01LjYtNDEuNi01LjYKCXMtMjguNCwxLjktNDEuNiw1LjZjMCwwLTMxLjgtMjIuMi00NS43LTE3LjljLTkuMSwyMi45LTMuNSw0MC42LTEuNyw0NWMtMTAuNiwxMS43LTE1LjYsMjAuOC0xNS42LDM5YzAsNjMuNiwzNy4zLDY5LDc0LjMsNzMuMQoJYy00LjgsNC4zLTkuMSwxMS43LTEwLjYsMjIuM2MtOS41LDQuMy0zMy44LDExLjctNDguMy0xMy45Yy05LjEtMTUuOC0yNS41LTE3LjEtMjUuNS0xNy4xYy0xNi4yLTAuMi0xLjEsMTAuMi0xLjEsMTAuMgoJYzEwLjgsNSwxOC40LDI0LjIsMTguNCwyNC4yYzkuNywyOS43LDU2LjEsMTkuNyw1Ni4xLDE5LjdjMCwxMy45LDAuMiwzNi41LDAuMiw0MC42YzAsNC4zLTMsOS41LTExLjUsOAoJYy02Ni0yMi4xLTExMi4yLTg0LjktMTEyLjItMTU4LjNjMC05MS44LDcwLjItMTYxLjUsMTYyLTE2MS41UzM4OCwxNjUuNiwzODgsMjU3LjRDMzg4LjEsMzMwLjgsMzQzLjMsMzkzLjcsMjc3LjMsNDE1Ljd6CgkgTTE3OS4yLDM1NC42Yy0xLjksMC40LTMuNy0wLjQtMy45LTEuN2MtMC4yLTEuNSwxLjEtMi44LDMtMy4yYzEuOS0wLjIsMy43LDAuNiwzLjksMS45QzE4Mi41LDM1Mi45LDE4MS4yLDM1NC4yLDE3OS4yLDM1NC42CglMMTc5LjIsMzU0LjZ6IE0xNjkuNywzNTMuN2MwLDEuMy0xLjUsMi40LTMuNSwyLjRjLTIuMiwwLjItMy43LTAuOS0zLjctMi40YzAtMS4zLDEuNS0yLjQsMy41LTIuNAoJQzE2Ny45LDM1MS4xLDE2OS43LDM1Mi4yLDE2OS43LDM1My43eiBNMTU2LDM1Mi42Yy0wLjQsMS4zLTIuNCwxLjktNC4xLDEuM2MtMS45LTAuNC0zLjItMS45LTIuOC0zLjJjMC40LTEuMywyLjQtMS45LDQuMS0xLjUKCUMxNTUuMiwzNDkuOCwxNTYuNSwzNTEuMywxNTYsMzUyLjZMMTU2LDM1Mi42eiBNMTQzLjcsMzQ3LjJjLTAuOSwxLjEtMi44LDAuOS00LjMtMC42Yy0xLjUtMS4zLTEuOS0zLjItMC45LTQuMQoJYzAuOS0xLjEsMi44LTAuOSw0LjMsMC42QzE0NC4xLDM0NC40LDE0NC42LDM0Ni40LDE0My43LDM0Ny4yeiBNMTM0LjYsMzM4LjFjLTAuOSwwLjYtMi42LDAtMy43LTEuNXMtMS4xLTMuMiwwLTMuOQoJYzEuMS0wLjksMi44LTAuMiwzLjcsMS4zQzEzNS43LDMzNS41LDEzNS43LDMzNy4zLDEzNC42LDMzOC4xeiBNMTI4LjEsMzI4LjRjLTAuOSwwLjktMi40LDAuNC0zLjUtMC42Yy0xLjEtMS4zLTEuMy0yLjgtMC40LTMuNQoJYzAuOS0wLjksMi40LTAuNCwzLjUsMC42QzEyOC44LDMyNi4yLDEyOSwzMjcuNywxMjguMSwzMjguNHogTTEyMS40LDMyMWMtMC40LDAuOS0xLjcsMS4xLTIuOCwwLjRjLTEuMy0wLjYtMS45LTEuNy0xLjUtMi42CgljMC40LTAuNiwxLjUtMC45LDIuOC0wLjRDMTIxLjIsMzE5LjEsMTIxLjgsMzIwLjIsMTIxLjQsMzIxeiIvPgo8L3N2Zz4K"/></a><a href="https://gitlab.com/rusith" class="Sidebar_socialButton___U_F2" target="_blank" rel="noreferrer"><img alt="Gitlab icon" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1MTIgNTEyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6I0ZGRkZGRjt9Cjwvc3R5bGU+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xMDUuMiwyNC45Yy0zLjEtOC45LTE1LjctOC45LTE4LjksMEwyOS44LDE5OS43aDEzMkMxNjEuNywxOTkuNywxMDUuMiwyNC45LDEwNS4yLDI0Ljl6IE0wLjksMjg3LjcKCWMtMi42LDgsMC4zLDE2LjksNy4xLDIybDI0Ny45LDE4NGwtMjI2LjItMjk0TDAuOSwyODcuN3ogTTE2MS43LDE5OS43bDk0LjMsMjk0bDk0LjMtMjk0SDE2MS43eiBNNTExLjEsMjg3LjdsLTI4LjgtODhMMjU2LDQ5My43CglsMjQ3LjktMTg0QzUxMC44LDMwNC42LDUxMy42LDI5NS43LDUxMS4xLDI4Ny43eiBNNDI1LjcsMjQuOWMtMy4xLTguOS0xNS43LTguOS0xOC45LDBsLTU2LjYsMTc0LjhoMTMyTDQyNS43LDI0Ljl6Ii8+Cjwvc3ZnPgo="/></a><a href="http://goodreads.com/rusith" class="Sidebar_socialButton___U_F2" target="_blank" rel="noreferrer"><img alt="GoodReads icon" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA0NDggNTEyIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0NDggNTEyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6I0ZGRkZGRjt9Cjwvc3R5bGU+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0yOTkuOSwxOTEuMmM1LjEsMzcuMy00LjcsNzktMzUuOSwxMDAuN2MtMjIuMywxNS41LTUyLjgsMTQuMS03MC44LDUuN2MtMzcuMS0xNy4zLTQ5LjUtNTguNi00Ni44LTk3LjIKCWM0LjMtNjAuOSw0MC45LTg3LjksNzUuMy04Ny41QzI2OC42LDExMi43LDI5My41LDE0NC43LDI5OS45LDE5MS4yTDI5OS45LDE5MS4yeiBNNDQ4LDg4djMzNmMwLDMwLjktMjUuMSw1Ni01Niw1Nkg1NgoJYy0zMC45LDAtNTYtMjUuMS01Ni01NlY4OGMwLTMwLjksMjUuMS01Niw1Ni01NmgzMzZDNDIyLjksMzIsNDQ4LDU3LjEsNDQ4LDg4eiBNMzMwLDMxMy4yYzAsMC0wLjEtMzQtMC4xLTIxNy4zaC0yOXY0MC4zCgljLTAuOCwwLjMtMS4yLTAuNS0xLjYtMS4yYy05LjYtMjAuNy0zNS45LTQ2LjMtNzYtNDZjLTUxLjksMC40LTg3LjIsMzEuMi0xMDAuNiw3Ny44Yy00LjMsMTQuOS01LjgsMzAuMS01LjUsNDUuNgoJYzEuNyw3Ny45LDQ1LjEsMTE3LjgsMTEyLjQsMTE1LjJjMjguOS0xLjEsNTQuNS0xNyw2OS00NS4yYzAuNS0xLDEuMS0xLjksMS43LTIuOWMwLjIsMC4xLDAuNCwwLjEsMC42LDAuMgoJYzAuMywzLjgsMC4yLDMwLjcsMC4xLDM0LjVjLTAuMiwxNC44LTIsMjkuNS03LjIsNDMuNWMtNy44LDIxLTIyLjMsMzQuNy00NC41LDM5LjVjLTE3LjgsMy45LTM1LjYsMy44LTUzLjItMS4yCgljLTIxLjUtNi4xLTM2LjUtMTktNDEuMS00MS44Yy0wLjMtMS42LTEuMy0xLjMtMi4zLTEuM2gtMjYuOGMwLjgsMTAuNiwzLjIsMjAuMyw4LjUsMjkuMmMyNC4yLDQwLjUsODIuNyw0OC41LDEyOC4yLDM3LjQKCUMzMTIuNSw0MDcuMiwzMjkuOSwzNjQuNiwzMzAsMzEzLjJMMzMwLDMxMy4yeiIvPgo8L3N2Zz4K"/></a><a href="https://twitter.com/rusith_" class="Sidebar_socialButton___U_F2" target="_blank" rel="noreferrer"><img alt="Twitter icon" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA0NDggNTEyIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0NDggNTEyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6I0ZGRkZGRjt9Cjwvc3R5bGU+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MDAsMzJINDhDMjEuNSwzMiwwLDUzLjUsMCw4MHYzNTJjMCwyNi41LDIxLjUsNDgsNDgsNDhoMzUyYzI2LjUsMCw0OC0yMS41LDQ4LTQ4VjgwCglDNDQ4LDUzLjUsNDI2LjUsMzIsNDAwLDMyeiBNMzUxLjEsMTkwLjhjMC4yLDIuOCwwLjIsNS43LDAuMiw4LjVjMCw4Ni43LTY2LDE4Ni42LTE4Ni42LDE4Ni42Yy0zNy4yLDAtNzEuNy0xMC44LTEwMC43LTI5LjQKCWM1LjMsMC42LDEwLjQsMC44LDE1LjgsMC44YzMwLjcsMCw1OC45LTEwLjQsODEuNC0yOGMtMjguOC0wLjYtNTMtMTkuNS02MS4zLTQ1LjVjMTAuMSwxLjUsMTkuMiwxLjUsMjkuNi0xLjIKCWMtMzAtNi4xLTUyLjUtMzIuNS01Mi41LTY0LjR2LTAuOGM4LjcsNC45LDE4LjksNy45LDI5LjYsOC4zYy0xOC4zLTEyLjItMjkuMi0zMi43LTI5LjItNTQuNmMwLTEyLjIsMy4yLTIzLjQsOC45LTMzLjEKCWMzMi4zLDM5LjgsODAuOCw2NS44LDEzNS4yLDY4LjZjLTkuMy00NC41LDI0LTgwLjYsNjQtODAuNmMxOC45LDAsMzUuOSw3LjksNDcuOSwyMC43YzE0LjgtMi44LDI5LTguMyw0MS42LTE1LjgKCWMtNC45LDE1LjItMTUuMiwyOC0yOC44LDM2LjFjMTMuMi0xLjQsMjYtNS4xLDM3LjgtMTAuMkMzNzUuMSwxNjkuOSwzNjMuOSwxODEuNSwzNTEuMSwxOTAuOHoiLz4KPC9zdmc+Cg=="/></a><a href="https://www.facebook.com/shanaka.rusith" class="Sidebar_socialButton___U_F2" target="_blank" rel="noreferrer"><img alt="Facebook icon" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA0NDggNTEyIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0NDggNTEyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6I0ZGRkZGRjt9Cjwvc3R5bGU+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MDAsMzJINDhDMjEuNSwzMiwwLDUzLjUsMCw4MHYzNTJjMCwyNi41LDIxLjUsNDgsNDgsNDhoMTM3LjNWMzI3LjdoLTYzVjI1Nmg2M3YtNTQuNgoJYzAtNjIuMiwzNy05Ni41LDkzLjctOTYuNWMyNy4xLDAsNTUuNSw0LjgsNTUuNSw0Ljh2NjFoLTMxLjNjLTMwLjgsMC00MC40LDE5LjEtNDAuNCwzOC43VjI1Nmg2OC44bC0xMSw3MS43aC01Ny44VjQ4MEg0MDAKCWMyNi41LDAsNDgtMjEuNSw0OC00OFY4MEM0NDgsNTMuNSw0MjYuNSwzMiw0MDAsMzJ6Ii8+Cjwvc3ZnPgo="/></a></div><p>A blog from a tech and art enthusiast</p></div><div class="Sidebar_nav__CTYKS"><div class="Sidebar_tagWrapper__w460D"><a href="/tag/programming/"><span class="Sidebar_tag__mAo8y">#<!-- -->programming</span></a><a href="/tag/aws/"><span class="Sidebar_tag__mAo8y">#<!-- -->aws</span></a><a href="/tag/web/"><span class="Sidebar_tag__mAo8y">#<!-- -->web</span></a><a href="/tag/machineLearning/"><span class="Sidebar_tag__mAo8y">#<!-- -->machineLearning</span></a><a href="/tag/react/"><span class="Sidebar_tag__mAo8y">#<!-- -->react</span></a><a href="/tag/javascript/"><span class="Sidebar_tag__mAo8y">#<!-- -->javascript</span></a><a href="/tag/dataScience/"><span class="Sidebar_tag__mAo8y">#<!-- -->dataScience</span></a><a href="/tag/typescript/"><span class="Sidebar_tag__mAo8y">#<!-- -->typescript</span></a><a href="/tag/r/"><span class="Sidebar_tag__mAo8y">#<!-- -->r</span></a><a href="/tag/csharp/"><span class="Sidebar_tag__mAo8y">#<!-- -->csharp</span></a></div></div></div></div><div class="comp_content__73ns2"><div><h1>Deploying an app on AWS ECS with CDK</h1><div class="Post_tags__HKWUb"><a class="Post_tag__5GXoX" href="https://rusith.me/tag/programming">#<!-- -->programming</a><a class="Post_tag__5GXoX" href="https://rusith.me/tag/nextJS">#<!-- -->nextJS</a><a class="Post_tag__5GXoX" href="https://rusith.me/tag/react">#<!-- -->react</a><a class="Post_tag__5GXoX" href="https://rusith.me/tag/aws">#<!-- -->aws</a><a class="Post_tag__5GXoX" href="https://rusith.me/tag/ecs">#<!-- -->ecs</a><a class="Post_tag__5GXoX" href="https://rusith.me/tag/typescript">#<!-- -->typescript</a><a class="Post_tag__5GXoX" href="https://rusith.me/tag/cdk">#<!-- -->cdk</a><a class="Post_tag__5GXoX" href="https://rusith.me/tag/devops">#<!-- -->devops</a></div><span class="Post_date__h8Of6">Wed, Feb 15, 2023</span><div><p><img alt="Page banner" class="Post_banner__soX4H" src="https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/banner.png"></p>
<p>In this article, I am trying to demonstrate the steps to get an application running on AWS ECS with load-balancing and auto-scaling enabled using CDK. We will be writing the CDK code using TypeScript</p>
<p>I am choosing NextJS to build this application, mainly because NextJS is a full-stack framework and it makes sense to enable auto-scaling on such an application. but this could be any app/API. which has an endpoint that returns some HTML.</p>
<h3 id="rootfolderstructure">Root folder Structure</h3>
<p>Let's first define the basic folder structure of this project, We will have the folder <code>app</code>
which will contain our application code and the <code>infra</code> folder will contain the infrastructure definition
that we are going to write using CDK.</p>
<h3 id="creatingtheapplication">Creating the application</h3>
<p>As I previously mentioned, I am going to use NextJS to write my application
And I will not do any changes to the NextJS boilerplate code
as it is not important what the application does at this moment.</p>
<p>Let's first initialize a new NextJS app inside the <code>app</code> directory by running the below command inside the <code>app</code> directory.</p>
<pre><code class="hljs sh language-sh"><span class="hljs-built_in">cd</span> app &amp;&amp; npx create-next-app@latest --typescript .
</code></pre>
<p>Which will result in a folder structure like this:</p>
<p><img src="https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/folder-structure-1.png" /></p>
<h3 id="containerizetheapplication">Containerize the application</h3>
<p>Now we have our application, we have to dockerize it in order to deploy it using CDK.
We can dockerize a NextJS application by creating a <code>Dockerfile</code> inside the <code>app</code> folder</p>
<p>This is a simple <code>Dockerfile</code> that we can use to dockerize our application, but you can change it based on your requirements.</p>
<pre><code class="hljs Dockerfile language-Dockerfile"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">18</span>-alpine
<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3000</span>

<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /app</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span>

<span class="hljs-keyword">COPY</span><span class="language-bash"> . /app</span>

<span class="hljs-keyword">RUN</span><span class="language-bash"> yarn install</span>
<span class="hljs-keyword">ENV</span> NODE_ENV=production

<span class="hljs-keyword">RUN</span><span class="language-bash"> yarn build</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;yarn&quot;</span>, <span class="hljs-string">&quot;start&quot;</span>]</span>
</code></pre>
<p>Now we are ready from the app side.</p>
<h3 id="initializingthecdkapplication">Initializing the CDK application</h3>
<p>To initialize the CDK application, we have to run the below command inside the <code>infra</code>
directory. This will generate the code necessary to get started with defining
the infrastructure of the project.</p>
<pre><code class="hljs sh language-sh">cdk init app --language typescript .
</code></pre>
<p>The new folder structure inside <code>infra</code> folder will look like this</p>
<p><img src="https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/folder-structure-2.png" /></p>
<p>Now, let's change the content of the <code>bin/infra.ts</code> file to the code below,
This is the entry point of the CDK application. We are initializing the <code>InfraStack</code> which
we import from <code>lib</code> folder.</p>
<pre><code class="hljs ts language-ts"><span class="hljs-meta">#!/usr/bin/env node</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;source-map-support/register&quot;</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> cdk <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;aws-cdk-lib&quot;</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">InfraStack</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../lib/infra-stack&quot;</span>

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> cdk.<span class="hljs-title class_">App</span>()
<span class="hljs-keyword">new</span> <span class="hljs-title class_">InfraStack</span>(app, <span class="hljs-string">&quot;InfraStack&quot;</span>)
</code></pre>
<h3 id="definingtheinfrastructure">Defining the infrastructure</h3>
<p>Now we are ready to define the infrastructure of the project. To make it easier, I will only have one file
which is <code>lib/infra-stack.ts</code> and I will define all the resources in this file. But it is a good practice to
break the infrastructure into multiple files and import them in the <code>infra-stack.ts</code> file.</p>
<p>As the initial step, let's change <code>lib/infra-stack.ts</code> file,</p>
<pre><code class="hljs ts language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Stack</span>, <span class="hljs-title class_">StackProps</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;aws-cdk-lib&quot;</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Construct</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;constructs&quot;</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InfraStack</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Stack</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">scope: Construct, id: <span class="hljs-built_in">string</span>, props?: StackProps</span>) {
    <span class="hljs-variable language_">super</span>(scope, id, {
      <span class="hljs-attr">env</span>: {
        <span class="hljs-attr">account</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">AWS_ACCOUNT_ID</span>,
        <span class="hljs-attr">region</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">AWS_DEFAULT_REGION</span>
      }
    })
  }
}
</code></pre>
<p>Here we are initializing the stack and setting the <code>account</code> and <code>region</code> from the environment variables.
Having the <code>account</code> and <code>region</code> is required to deploy the stack.</p>
<h4 id="definingthevpc">Defining the VPC</h4>
<p>Let's start by creating a VPC for our application. All other resources will be created inside this VPC.</p>
<pre><code class="hljs ts language-ts"><span class="hljs-keyword">const</span> vpc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vpc</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;AppVPC&quot;</span>, {
  <span class="hljs-attr">natGateways</span>: <span class="hljs-number">0</span>
})
</code></pre>
<h4 id="definingtheecscluster">Defining the ECS cluster</h4>
<p>Now we have to define an ECS cluster that contains all resources related to our ECS.</p>
<pre><code class="hljs ts language-ts"><span class="hljs-keyword">const</span> cluster = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cluster</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;Cluster&quot;</span>, { vpc })
</code></pre>
<h4 id="definingapptask">Defining app task</h4>
<p>Before defining the task, we have to define a role for the task.
This role has to be based on the <code>ecs-tasks.amazonaws.com</code> role.</p>
<pre><code class="hljs ts language-ts"><span class="hljs-keyword">const</span> taskRole = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Role</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;AppRole&quot;</span>, {
  <span class="hljs-attr">assumedBy</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServicePrincipal</span>(<span class="hljs-string">&quot;ecs-tasks.amazonaws.com&quot;</span>)
})
</code></pre>
<p>Now we have to add required permissions to the role,
These permissions could change based on the requirements of the project.
For this project, we are going to add permissions for <code>log</code> and <code>CloudWatch</code>.</p>
<pre><code class="hljs ts language-ts">taskRole.<span class="hljs-title function_">addToPolicy</span>(
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">PolicyStatement</span>({
    <span class="hljs-attr">resources</span>: [<span class="hljs-string">&quot;*&quot;</span>],
    <span class="hljs-attr">actions</span>: [<span class="hljs-string">&quot;logs:*&quot;</span>, <span class="hljs-string">&quot;cloudwatch:*&quot;</span>]
  })
)
</code></pre>
<p>Now we are ready to define the task. The task is the basic unit that runs on the actual container. As we are targeting EC2, we have to define the <code>compatibility</code> as <code>EC2</code>. And <code>obtainExecutionRole</code> will create the execution role for this task if it does not exist.</p>
<pre><code class="hljs ts language-ts"><span class="hljs-keyword">const</span> taskDefinition = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskDefinition</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;AppTask&quot;</span>, {
  taskRole,
  <span class="hljs-attr">compatibility</span>: <span class="hljs-title class_">Compatibility</span>.<span class="hljs-property">EC2</span>
})
taskDefinition.<span class="hljs-title function_">obtainExecutionRole</span>()
</code></pre>
<h4 id="definingtheautoscalinggroup">Defining the auto-scaling group</h4>
<p>Now we have to define an auto-scaling group that will handle the
creation and destruction of the EC2 instances. based on the
requirements of the capacity provider which will be defined later.
Here I am using a <code>t3.nano</code> instance type, this can be changed based on the requirements. And I am setting the <code>desiredCapacity</code> to <code>0</code> so that no instances will be created at the beginning.</p>
<pre><code class="hljs ts language-ts"><span class="hljs-keyword">const</span> asg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoScalingGroup</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;ASG&quot;</span>, {
  <span class="hljs-attr">instanceType</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstanceType</span>(<span class="hljs-string">&quot;t3.nano&quot;</span>),
  <span class="hljs-attr">machineImage</span>: <span class="hljs-title class_">EcsOptimizedImage</span>.<span class="hljs-title function_">amazonLinux2</span>(),
  <span class="hljs-attr">associatePublicIpAddress</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">maxCapacity</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">desiredCapacity</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">minCapacity</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">vpc</span>: vpc,
  <span class="hljs-attr">vpcSubnets</span>: { <span class="hljs-attr">subnetType</span>: <span class="hljs-title class_">SubnetType</span>.<span class="hljs-property">PUBLIC</span> },
  <span class="hljs-attr">newInstancesProtectedFromScaleIn</span>: <span class="hljs-literal">false</span>
})
</code></pre>
<h4 id="definingthecapacityprovider">Defining the capacity provider</h4>
<p>We are going to use the capacity provider to connect the auto-scaling group and the ECS cluster. This will handle all the scaling scenarios. I am setting the <code>enableManagedScaling</code> to <code>true</code> so that the capacity provider will handle the scaling of the instances. And I am setting the <code>targetCapacityPercent</code> to <code>100</code> so that the capacity provider will always try to keep the instances at 100% capacity and will not create additional instances. It's also important to note, by setting the <code>enableManagedTerminationProtection</code> to <code>false</code> we are allowing the capacity provider to terminate the instances if it is required.</p>
<pre><code class="hljs ts language-ts"><span class="hljs-keyword">const</span> capacityProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsgCapacityProvider</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;EC2CapacityProvider&quot;</span>, {
  <span class="hljs-attr">autoScalingGroup</span>: asg,
  <span class="hljs-attr">enableManagedScaling</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">enableManagedTerminationProtection</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">targetCapacityPercent</span>: <span class="hljs-number">100</span>
})

cluster.<span class="hljs-title function_">addAsgCapacityProvider</span>(capacityProvider)
</code></pre>
<h4 id="definingtheappservice">Defining the app service</h4>
<p>Now we are ready to define the service which will contain the task. I am setting the <code>minHealthyPercent</code> to <code>0</code> so that the service will not wait for the instances to be healthy before starting the deployment. And I am setting the <code>capacityProviderStrategies</code> to use the capacity provider which we defined earlier.</p>
<pre><code class="hljs ts language-ts"><span class="hljs-keyword">const</span> service = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ec2Service</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;AppService&quot;</span>, {
  taskDefinition,
  cluster,
  <span class="hljs-attr">desiredCount</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">minHealthyPercent</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">capacityProviderStrategies</span>: [
    {
      <span class="hljs-attr">capacityProvider</span>: capacityProvider.<span class="hljs-property">capacityProviderName</span>,
      <span class="hljs-attr">weight</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">base</span>: <span class="hljs-number">0</span>
    }
  ]
})
</code></pre>
<h4 id="definingthecontainer">Defining the container</h4>
<p>Now we are ready to define the container where the task will be running, Here I am
using <code>ContainerImage.fromAsset</code> to build the image from the local directory. CDK will
build the image locally and push it to ECR. I am also using <code>awsLogs</code> driver to push the logs to CloudWatch. And I am setting the <code>memoryReservationMiB</code> to <code>200</code> so that the container will have a minimum of 200MB of memory. This amount can be changed based on the
requirements of the application. This value will be taken into consideration when scaling the app. And I am also mapping port <code>3000</code> of the container to port <code>3000</code> of the host. As NextJS is by default running on port <code>3000</code>.</p>
<pre><code class="hljs ts language-ts"><span class="hljs-keyword">const</span> container = taskDefinition.<span class="hljs-title function_">addContainer</span>(<span class="hljs-string">&quot;AppContainer&quot;</span>, {
  <span class="hljs-attr">linuxParameters</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinuxParameters</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;AppLinuxParams&quot;</span>),
  <span class="hljs-attr">image</span>: <span class="hljs-title class_">ContainerImage</span>.<span class="hljs-title function_">fromAsset</span>(<span class="hljs-string">&quot;../app&quot;</span>),
  <span class="hljs-attr">logging</span>: <span class="hljs-title class_">LogDriver</span>.<span class="hljs-title function_">awsLogs</span>({
    <span class="hljs-attr">streamPrefix</span>: <span class="hljs-string">&quot;app&quot;</span>,
    <span class="hljs-attr">logRetention</span>: <span class="hljs-title class_">RetentionDays</span>.<span class="hljs-property">ONE_WEEK</span>
  }),
  <span class="hljs-attr">environment</span>: {
    <span class="hljs-attr">NODE_ENV</span>: <span class="hljs-string">&quot;production&quot;</span>
  },
  <span class="hljs-attr">memoryReservationMiB</span>: <span class="hljs-number">200</span>
})

container.<span class="hljs-title function_">addPortMappings</span>({
  <span class="hljs-attr">containerPort</span>: <span class="hljs-number">3000</span>,
  <span class="hljs-attr">hostPort</span>: <span class="hljs-number">3000</span>,
  <span class="hljs-attr">protocol</span>: <span class="hljs-title class_">ECSProtocol</span>.<span class="hljs-property">TCP</span>
})
</code></pre>
<h3 id="httpcertificate">HTTP certificate</h3>
<p>Now we have to have a certificate for the domain which we are going to use. This certificate will be used by the load balancer to serve the traffic over HTTPS. Make sure you create this certificate in the <code>us-east-1</code> region. This is a requirement for the load balancer.</p>
<p>As we are not in the <code>us-east-1</code> region, we have to import the certificate using the <code>Certificate.fromCertificateArn</code> method. You can copy the ARN of the certificate from the AWS console. I am setting the <code>APP_CERTIFICATE_ARN</code> environment variable to the ARN of the certificate.</p>
<pre><code class="hljs ts language-ts"><span class="hljs-keyword">const</span> domainCertificate = <span class="hljs-title class_">Certificate</span>.<span class="hljs-title function_">fromCertificateArn</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;AppCertificate&quot;</span>, process.<span class="hljs-property">env</span>.<span class="hljs-property">APP_CERTIFICATE_ARN</span>!)
</code></pre>
<h3 id="definingtheloadbalancer">Defining the load balancer</h3>
<p>Now we are ready to define the load balancer,</p>
<pre><code class="hljs ts language-ts"><span class="hljs-keyword">const</span> loadBalancer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationLoadBalancer</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;AppLoadBalancer&quot;</span>, {
  vpc,
  <span class="hljs-attr">internetFacing</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">vpcSubnets</span>: { <span class="hljs-attr">subnetType</span>: <span class="hljs-title class_">SubnetType</span>.<span class="hljs-property">PUBLIC</span> }
})
</code></pre>
<h5 id="redirectinghttptohttps">Redirecting HTTP to HTTPS</h5>
<p>We will redirect the HTTP traffic to HTTPS. This is done by adding a redirect rule to the load balancer. This will redirect all the traffic coming from port <code>80</code> to port <code>443</code> over HTTPS.</p>
<pre><code class="hljs ts language-ts">loadBalancer.<span class="hljs-title function_">addRedirect</span>({
  <span class="hljs-attr">sourcePort</span>: <span class="hljs-number">80</span>,
  <span class="hljs-attr">sourceProtocol</span>: <span class="hljs-title class_">ApplicationProtocol</span>.<span class="hljs-property">HTTP</span>,
  <span class="hljs-attr">targetPort</span>: <span class="hljs-number">443</span>,
  <span class="hljs-attr">targetProtocol</span>: <span class="hljs-title class_">ApplicationProtocol</span>.<span class="hljs-property">HTTPS</span>
})
</code></pre>
<h5 id="allowegresstraffic">Allow egress traffic</h5>
<p>We have to allow the load balancer to make requests to the internet. This is done by adding a security group rule to the load balancer.</p>
<pre><code class="hljs ts language-ts">loadBalancer.<span class="hljs-property">connections</span>.<span class="hljs-title function_">allowToAnyIpv4</span>(<span class="hljs-title class_">Port</span>.<span class="hljs-title function_">allTcp</span>(), <span class="hljs-string">&quot;All Out&quot;</span>)
</code></pre>
<h5 id="connectingtheloadbalancertotheapp">Connecting the load balancer to the app</h5>
<p>Now we are ready to connect the load balancer to the app.
First, we will create a listener on port 443 and add the certificate which we created earlier.
Then we can add the app service as a target to the listener.</p>
<p>Ans we also have to make sure the load balancer can be accessed from the internet. This can be done
using <code>allowFromAnyIpv4</code> method for ports <code>80</code> and <code>443</code>.</p>
<p>Finally, we will allow the load balancer to make requests to the app on port <code>3000</code>.</p>
<pre><code class="hljs ts language-ts"><span class="hljs-keyword">const</span> listener = loadBalancer.<span class="hljs-title function_">addListener</span>(<span class="hljs-string">&quot;AutomateListener&quot;</span>, {
  <span class="hljs-attr">port</span>: <span class="hljs-number">443</span>,
  <span class="hljs-attr">certificates</span>: [domainCertificate],
  <span class="hljs-attr">protocol</span>: <span class="hljs-title class_">ApplicationProtocol</span>.<span class="hljs-property">HTTPS</span>
})

listener.<span class="hljs-title function_">addTargets</span>(<span class="hljs-string">&quot;AppTarget&quot;</span>, {
  <span class="hljs-attr">healthCheck</span>: {
    <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">protocol</span>: <span class="hljs-title class_">Protocol</span>.<span class="hljs-property">HTTP</span>
  },
  <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>,
  <span class="hljs-attr">deregistrationDelay</span>: <span class="hljs-title class_">Duration</span>.<span class="hljs-title function_">seconds</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>,
  <span class="hljs-attr">protocol</span>: <span class="hljs-title class_">ApplicationProtocol</span>.<span class="hljs-property">HTTP</span>,
  <span class="hljs-attr">targets</span>: [service]
})

loadBalancer.<span class="hljs-property">connections</span>.<span class="hljs-title function_">allowFromAnyIpv4</span>(<span class="hljs-title class_">Port</span>.<span class="hljs-title function_">tcp</span>(<span class="hljs-number">80</span>), <span class="hljs-string">&quot;Ingress HTTP internet&quot;</span>)
loadBalancer.<span class="hljs-property">connections</span>.<span class="hljs-title function_">allowFromAnyIpv4</span>(<span class="hljs-title class_">Port</span>.<span class="hljs-title function_">tcp</span>(<span class="hljs-number">443</span>), <span class="hljs-string">&quot;Ingress HTTPS internet&quot;</span>)

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> subnet <span class="hljs-keyword">of</span> vpc.<span class="hljs-property">publicSubnets</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>) {
  asg.<span class="hljs-property">connections</span>.<span class="hljs-title function_">allowFrom</span>(<span class="hljs-title class_">Peer</span>.<span class="hljs-title function_">ipv4</span>(subnet.<span class="hljs-property">ipv4CidrBlock</span>), <span class="hljs-title class_">Port</span>.<span class="hljs-title function_">tcp</span>(<span class="hljs-number">3000</span>), <span class="hljs-string">&quot;Ingress from ALB to App&quot;</span>)
}
</code></pre>
<h3 id="hostedzoneandsubdomain">Hosted zone and subdomain</h3>
<p>As my domain is handled by AWS, I will add the subdomain to the hosted zone also here, If this is not the case for you, you can skip this step and directly point the domain to the load balancer's public IP which you can find after the deployment is done in the AWS console.</p>
<pre><code class="hljs ts language-ts"><span class="hljs-keyword">const</span> hostedZone = <span class="hljs-title class_">PublicHostedZone</span>.<span class="hljs-title function_">fromLookup</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;HostedZone&quot;</span>, {
  <span class="hljs-attr">domainName</span>: <span class="hljs-string">&quot;&lt;some-domain&gt;.com&quot;</span>
})

<span class="hljs-keyword">new</span> <span class="hljs-title class_">ARecord</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;AppARecord&quot;</span>, {
  <span class="hljs-attr">zone</span>: hostedZone,
  <span class="hljs-attr">target</span>: <span class="hljs-title class_">RecordTarget</span>.<span class="hljs-title function_">fromAlias</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoadBalancerTarget</span>(loadBalancer <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)),
  <span class="hljs-attr">recordName</span>: <span class="hljs-string">&quot;app&quot;</span>
})
</code></pre>
<h3 id="deployingtheapp">Deploying the app,</h3>
<p>Now our infrastructure definition is ready to go.
Before deploying, we have to bootstrap the application, Before that, we have to make sure we have
the AWS credentials are set in the environment variables. And also make sure the <code>AWS_ACCOUNT_ID</code>
and <code>APP_CERTIFICATE_ARN</code> environment variables are set.</p>
<pre><code class="hljs sh language-sh"><span class="hljs-comment"># For bash:</span>
<span class="hljs-built_in">export</span> AWS_ACCOUNT_ID=<span class="hljs-string">&quot;&lt;AWS_ACCOUNT_ID&gt;&quot;</span>
<span class="hljs-built_in">export</span> AWS_ACCESS_KEY_ID=<span class="hljs-string">&quot;&lt;AWS_ACCESS_KEY_ID&gt;&quot;</span>
<span class="hljs-built_in">export</span> AWS_SECRET_ACCESS_KEY=<span class="hljs-string">&quot;&lt;AWS_SECRET_ACCESS_KEY&gt;&quot;</span>
<span class="hljs-built_in">export</span> AWS_DEFAULT_REGION=<span class="hljs-string">&quot;&lt;REGION&gt;&quot;</span>
<span class="hljs-built_in">export</span> APP_CERTIFICATE_ARN=<span class="hljs-string">&quot;arn:aws:acm:...&quot;</span>
</code></pre>
<p>Now we can run the below command inside the <code>infra</code> folder to bootstrap the app,</p>
<pre><code class="hljs sh language-sh">npx aws-cdk bootstrap
</code></pre>
<p><img src="https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/cdk-bootstrap-result.jpg" /></p>
<p>And finally, we can deploy the app using the below command, This will take some time because it has to build the app image and push that to the ECR registry. I am doing this completely from the local machine but the steps are the same if you are using a CI/CD pipeline.</p>
<p>Also, make sure Docker is running on your machine as the CDK will use the local Docker daemon to build the image.</p>
<pre><code class="hljs sh language-sh">npx aws-cdk deploy
</code></pre>
<p>Once the deployment is complete, It should return an output like below,</p>
<p><img src="https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/cdk-deploy-result.png" /></p>
<p>Now you should see the stack is created in the Cloudfomration console.</p>
<p><img src="https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/cloudformation-console.png" /></p>
<h3 id="testingtheapp">Testing the app</h3>
<p>Now we can test the app by visiting the domain which you used.</p>
<p><img src="https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/app.png" /></p>
<p>Now, If you increase the number of desired tasks for the service, The auto-scaling group will automatically facilitate the scaling by creating new instances.</p>
<h3 id="troubleshooting">Troubleshooting</h3>
<p>If you get the error <code>The runtime parameter of python3.6 is no longer supported for creating or updating AWS Lambda functions. We recommend you use the new runtime (python3.9)</code>,</p>
<p>Remove the <code>aws-cdk</code> package from the <code>package.json</code> file set the version for the package <code>aws-cdk-lib</code> to <code>^2.61.1</code>, install packages and run deploy again.</p>
<h3 id="sourcecode">Source code</h3>
<p>You can find the source code for this blog post <a href="https://github.com/rusith/2023-02-15-deploying-react-app-on-ecs">here</a></p></div></div><div class="Post_related__V0k3K"><h2>Related Posts</h2><ul class="Post_relatedPosts__co9O7"><li><h3><a href="https://rusith.me/blog/testing-react-redux-connected-components-using-jest">Testing Redux Connected React Components Using Jest<small>Mon, Apr 27, 2020</small></a></h3></li><li><h3><a href="https://rusith.me/blog/nuget-feed-on-s3">Running a Nuget Feed on S3 with Automated Deployments<small>Sat, Nov 2, 2019</small></a></h3></li><li><h3><a href="https://rusith.me/blog/building-a-website-on-s3">Deploying a Website on S3 With SSL, Continuous Integration<small>Mon, Aug 5, 2019</small></a></h3></li></ul></div><div id="disqus_thread"></div></div><div class="sbuttons"><a href="https://www.facebook.com/sharer/sharer.php?u=https://rusith.me/blog/deploy-app-on-aws-ecs-with-cdk-auto-scaling-and-load-balancing" target="_blank" class="sbutton fb" title="Share on Facebook" rel="noreferrer"><img alt="Facebook icon" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAzMjAgNTEyIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAzMjAgNTEyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6I0ZGRkZGRjt9Cjwvc3R5bGU+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0yNzkuMSwyODhsMTQuMi05Mi43aC04OC45di02MC4xYzAtMjUuMywxMi40LTUwLjEsNTIuMi01MC4xaDQwLjRWNi4zYzAsMC0zNi43LTYuMy03MS43LTYuMwoJYy03My4yLDAtMTIxLjEsNDQuNC0xMjEuMSwxMjQuN3Y3MC42SDIyLjlWMjg4aDgxLjR2MjI0aDEwMC4yVjI4OEgyNzkuMXoiLz4KPC9zdmc+Cg=="/></a><a href="https://twitter.com/intent/tweet?text=https://rusith.me/blog/deploy-app-on-aws-ecs-with-cdk-auto-scaling-and-load-balancing" target="_blank" class="sbutton twitt" title="Share on Twitter" rel="noreferrer"><img alt="Twitter icon" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1MTIgNTEyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6I0ZGRkZGRjt9Cjwvc3R5bGU+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00NTkuNCwxNTEuN2MwLjMsNC41LDAuMyw5LjEsMC4zLDEzLjZjMCwxMzguNy0xMDUuNiwyOTguNi0yOTguNiwyOTguNmMtNTkuNSwwLTExNC43LTE3LjItMTYxLjEtNDcuMQoJYzguNCwxLDE2LjYsMS4zLDI1LjMsMS4zYzQ5LjEsMCw5NC4yLTE2LjYsMTMwLjMtNDQuOGMtNDYuMS0xLTg0LjgtMzEuMi05OC4xLTcyLjhjNi41LDEsMTMsMS42LDE5LjgsMS42YzkuNCwwLDE4LjgtMS4zLDI3LjYtMy42CgljLTQ4LjEtOS43LTg0LjEtNTItODQuMS0xMDN2LTEuM2MxNCw3LjgsMzAuMiwxMi43LDQ3LjQsMTMuM2MtMjguMy0xOC44LTQ2LjgtNTEtNDYuOC04Ny40YzAtMTkuNSw1LjItMzcuNCwxNC4zLTUzCglDODcuNCwxMzAuOSwxNjUsMTcyLjUsMjUyLjEsMTc3LjFjLTEuNi03LjgtMi42LTE1LjktMi42LTI0YzAtNTcuOCw0Ni44LTEwNC45LDEwNC45LTEwNC45YzMwLjIsMCw1Ny41LDEyLjcsNzYuNywzMy4xCgljMjMuNy00LjUsNDYuNS0xMy4zLDY2LjYtMjUuM2MtNy44LDI0LjQtMjQuNCw0NC44LTQ2LjEsNTcuOGMyMS4xLTIuMyw0MS42LTguMSw2MC40LTE2LjJDNDk3LjcsMTE4LjMsNDc5LjgsMTM2LjgsNDU5LjQsMTUxLjcKCUw0NTkuNCwxNTEuN3oiLz4KPC9zdmc+Cg=="/></a><a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://rusith.me/blog/deploy-app-on-aws-ecs-with-cdk-auto-scaling-and-load-balancing&amp;title=&amp;summary=&amp;source=" target="_blank" class="sbutton linkedin" title="Share on Linkedin" rel="noreferrer"><img alt="LinkedIn icon" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA0NDggNTEyIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0NDggNTEyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6I0ZGRkZGRjt9Cjwvc3R5bGU+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xMDAuMyw0NDhINy40VjE0OC45aDkyLjlWNDQ4eiBNNTMuOCwxMDguMUMyNC4xLDEwOC4xLDAsODMuNSwwLDUzLjhDMCwyNC4xLDI0LjEsMCw1My44LDAKCWMyOS43LDAsNTMuOCwyNC4xLDUzLjgsNTMuOEMxMDcuNiw4My41LDgzLjUsMTA4LjEsNTMuOCwxMDguMXogTTQ0Ny45LDQ0OGgtOTIuN1YzMDIuNGMwLTM0LjctMC43LTc5LjItNDguMy03OS4yCgljLTQ4LjMsMC01NS43LDM3LjctNTUuNyw3Ni43VjQ0OGgtOTIuOFYxNDguOWg4OS4xdjQwLjhoMS4zYzEyLjQtMjMuNSw0Mi43LTQ4LjMsODcuOS00OC4zYzk0LDAsMTExLjMsNjEuOSwxMTEuMywxNDIuM1Y0NDhINDQ3Ljl6CgkiLz4KPC9zdmc+Cg=="/></a><a target="_blank" class="sbutton mainsbutton"><img alt="Share button" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA0NDggNTEyIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0NDggNTEyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6I0ZGRkZGRjt9Cjwvc3R5bGU+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0zNTIsMzIwYy0yNS42LDAtNDguOSwxMC02Ni4xLDI2LjRsLTk4LjMtNjEuNWM1LjktMTguOCw1LjktMzkuMSwwLTU3LjhsOTguMy02MS41CglDMzAzLjEsMTgyLDMyNi40LDE5MiwzNTIsMTkyYzUzLDAsOTYtNDMsOTYtOTZTNDA1LDAsMzUyLDBzLTk2LDQzLTk2LDk2YzAsOS44LDEuNSwxOS42LDQuNCwyOC45bC05OC4zLDYxLjUKCUMxNDQuOSwxNzAsMTIxLjYsMTYwLDk2LDE2MGMtNTMsMC05Niw0My05Niw5NnM0Myw5Niw5Niw5NmMyNS42LDAsNDguOS0xMCw2Ni4xLTI2LjRsOTguMyw2MS41Yy0yLjksOS40LTQuNCwxOS4xLTQuNCwyOC45CgljMCw1Myw0Myw5Niw5Niw5NnM5Ni00Myw5Ni05NlM0MDUsMzIwLDM1MiwzMjBMMzUyLDMyMHogTTM1Miw0OGMyNi41LDAsNDgsMjEuNSw0OCw0OHMtMjEuNSw0OC00OCw0OHMtNDgtMjEuNS00OC00OAoJUzMyNS41LDQ4LDM1Miw0OHogTTk2LDMwNGMtMjYuNSwwLTQ4LTIxLjUtNDgtNDhzMjEuNS00OCw0OC00OHM0OCwyMS41LDQ4LDQ4UzEyMi41LDMwNCw5NiwzMDR6IE0zNTIsNDY0Yy0yNi41LDAtNDgtMjEuNS00OC00OAoJczIxLjUtNDgsNDgtNDhzNDgsMjEuNSw0OCw0OFMzNzguNSw0NjQsMzUyLDQ2NHoiLz4KPC9zdmc+Cg=="/></a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"fileName":"2023-02-15-deploying-react-app-on-ecs.md","fullPath":"/home/runner/work/rusith.me/rusith.me/modules/blog/posts/2023-02-15-deploying-react-app-on-ecs.md","layout":"post","title":"Deploying an app on AWS ECS with CDK","tags":["programming","nextJS","react","aws","ecs","typescript","cdk","devops"],"comments":true,"description":"How to deploy an application on AWS ECS with load-balancing and auto-scaling using CDK by writing the CDK code in TypeScript","dateCreated":"Wed Feb 15 2023 00:00:00 GMT+0000 (Coordinated Universal Time)","dateModified":"Wed Feb 15 2023 00:00:00 GMT+0000 (Coordinated Universal Time)","datePublished":"Wed Feb 15 2023 00:00:00 GMT+0000 (Coordinated Universal Time)","about":"How to deploy an application on AWS ECS with load-balancing and auto-scaling using CDK by writing the CDK code in TypeScript","banner":"/post-data/2023-02-15-deploying-react-app-on-ecs/banner.png","path":"/blog/deploy-app-on-aws-ecs-with-cdk-auto-scaling-and-load-balancing","dateCreatedFormatted":"Wed, Feb 15, 2023","fullUrl":"https://rusith.me/blog/deploy-app-on-aws-ecs-with-cdk-auto-scaling-and-load-balancing","oldPath":null,"fileContent":"---\nlayout: post\ntitle: Deploying an app on AWS ECS with CDK\ntags: programming nextJS react aws ecs typescript cdk devops\ncomments: true\ndescription: How to deploy an application on AWS ECS with load-balancing and auto-scaling using CDK by writing the CDK code in TypeScript\ndateCreated: 2023-02-15\ndateModified: 2023-02-15\ndatePublished: 2023-02-15\nabout: How to deploy an application on AWS ECS with load-balancing and auto-scaling using CDK by writing the CDK code in TypeScript\nbanner: /post-data/2023-02-15-deploying-react-app-on-ecs/banner.png\npath: /deploy-app-on-aws-ecs-with-cdk-auto-scaling-and-load-balancing\n---\n\n\u003cimg alt=\"Page banner\" class=\"$$styles.banner\" src=\"$$page_banner_full_path\"\u003e\n\nIn this article, I am trying to demonstrate the steps to get an application running on AWS ECS with load-balancing and auto-scaling enabled using CDK. We will be writing the CDK code using TypeScript\n\nI am choosing NextJS to build this application, mainly because NextJS is a full-stack framework and it makes sense to enable auto-scaling on such an application. but this could be any app/API. which has an endpoint that returns some HTML.\n\n### Root folder Structure\n\nLet's first define the basic folder structure of this project, We will have the folder `app`\nwhich will contain our application code and the `infra` folder will contain the infrastructure definition\nthat we are going to write using CDK.\n\n### Creating the application\n\nAs I previously mentioned, I am going to use NextJS to write my application\nAnd I will not do any changes to the NextJS boilerplate code\nas it is not important what the application does at this moment.\n\nLet's first initialize a new NextJS app inside the `app` directory by running the below command inside the `app` directory.\n\n```sh\ncd app \u0026\u0026 npx create-next-app@latest --typescript .\n```\n\nWhich will result in a folder structure like this:\n\n\u003cimg src=\"$$base_url/post-data/2023-02-15-deploying-react-app-on-ecs/folder-structure-1.png\" /\u003e\n\n### Containerize the application\n\nNow we have our application, we have to dockerize it in order to deploy it using CDK.\nWe can dockerize a NextJS application by creating a `Dockerfile` inside the `app` folder\n\nThis is a simple `Dockerfile` that we can use to dockerize our application, but you can change it based on your requirements.\n\n```Dockerfile\nFROM node:18-alpine\nEXPOSE 3000\n\nRUN mkdir /app\nWORKDIR /app\n\nCOPY . /app\n\nRUN yarn install\nENV NODE_ENV=production\n\nRUN yarn build\nCMD [\"yarn\", \"start\"]\n\n```\n\nNow we are ready from the app side.\n\n### Initializing the CDK application\n\nTo initialize the CDK application, we have to run the below command inside the `infra`\ndirectory. This will generate the code necessary to get started with defining\nthe infrastructure of the project.\n\n```sh\ncdk init app --language typescript .\n```\n\nThe new folder structure inside `infra` folder will look like this\n\n\u003cimg src=\"$$base_url/post-data/2023-02-15-deploying-react-app-on-ecs/folder-structure-2.png\" /\u003e\n\nNow, let's change the content of the `bin/infra.ts` file to the code below,\nThis is the entry point of the CDK application. We are initializing the `InfraStack` which\nwe import from `lib` folder.\n\n```ts\n#!/usr/bin/env node\nimport \"source-map-support/register\"\nimport * as cdk from \"aws-cdk-lib\"\nimport { InfraStack } from \"../lib/infra-stack\"\n\nconst app = new cdk.App()\nnew InfraStack(app, \"InfraStack\")\n```\n\n### Defining the infrastructure\n\nNow we are ready to define the infrastructure of the project. To make it easier, I will only have one file\nwhich is `lib/infra-stack.ts` and I will define all the resources in this file. But it is a good practice to\nbreak the infrastructure into multiple files and import them in the `infra-stack.ts` file.\n\nAs the initial step, let's change `lib/infra-stack.ts` file,\n\n```ts\nimport { Stack, StackProps } from \"aws-cdk-lib\"\nimport { Construct } from \"constructs\"\n\nexport class InfraStack extends Stack {\n  constructor(scope: Construct, id: string, props?: StackProps) {\n    super(scope, id, {\n      env: {\n        account: process.env.AWS_ACCOUNT_ID,\n        region: process.env.AWS_DEFAULT_REGION\n      }\n    })\n  }\n}\n```\n\nHere we are initializing the stack and setting the `account` and `region` from the environment variables.\nHaving the `account` and `region` is required to deploy the stack.\n\n#### Defining the VPC\n\nLet's start by creating a VPC for our application. All other resources will be created inside this VPC.\n\n```ts\nconst vpc = new Vpc(this, \"AppVPC\", {\n  natGateways: 0\n})\n```\n\n#### Defining the ECS cluster\n\nNow we have to define an ECS cluster that contains all resources related to our ECS.\n\n```ts\nconst cluster = new Cluster(this, \"Cluster\", { vpc })\n```\n\n#### Defining app task\n\nBefore defining the task, we have to define a role for the task.\nThis role has to be based on the `ecs-tasks.amazonaws.com` role.\n\n```ts\nconst taskRole = new Role(this, \"AppRole\", {\n  assumedBy: new ServicePrincipal(\"ecs-tasks.amazonaws.com\")\n})\n```\n\nNow we have to add required permissions to the role,\nThese permissions could change based on the requirements of the project.\nFor this project, we are going to add permissions for `log` and `CloudWatch`.\n\n```ts\ntaskRole.addToPolicy(\n  new PolicyStatement({\n    resources: [\"*\"],\n    actions: [\"logs:*\", \"cloudwatch:*\"]\n  })\n)\n```\n\nNow we are ready to define the task. The task is the basic unit that runs on the actual container. As we are targeting EC2, we have to define the `compatibility` as `EC2`. And `obtainExecutionRole` will create the execution role for this task if it does not exist.\n\n```ts\nconst taskDefinition = new TaskDefinition(this, \"AppTask\", {\n  taskRole,\n  compatibility: Compatibility.EC2\n})\ntaskDefinition.obtainExecutionRole()\n```\n\n#### Defining the auto-scaling group\n\nNow we have to define an auto-scaling group that will handle the\ncreation and destruction of the EC2 instances. based on the\nrequirements of the capacity provider which will be defined later.\nHere I am using a `t3.nano` instance type, this can be changed based on the requirements. And I am setting the `desiredCapacity` to `0` so that no instances will be created at the beginning.\n\n```ts\nconst asg = new AutoScalingGroup(this, \"ASG\", {\n  instanceType: new InstanceType(\"t3.nano\"),\n  machineImage: EcsOptimizedImage.amazonLinux2(),\n  associatePublicIpAddress: true,\n  maxCapacity: 3,\n  desiredCapacity: 0,\n  minCapacity: 0,\n  vpc: vpc,\n  vpcSubnets: { subnetType: SubnetType.PUBLIC },\n  newInstancesProtectedFromScaleIn: false\n})\n```\n\n#### Defining the capacity provider\n\nWe are going to use the capacity provider to connect the auto-scaling group and the ECS cluster. This will handle all the scaling scenarios. I am setting the `enableManagedScaling` to `true` so that the capacity provider will handle the scaling of the instances. And I am setting the `targetCapacityPercent` to `100` so that the capacity provider will always try to keep the instances at 100% capacity and will not create additional instances. It's also important to note, by setting the `enableManagedTerminationProtection` to `false` we are allowing the capacity provider to terminate the instances if it is required.\n\n```ts\nconst capacityProvider = new AsgCapacityProvider(this, \"EC2CapacityProvider\", {\n  autoScalingGroup: asg,\n  enableManagedScaling: true,\n  enableManagedTerminationProtection: false,\n  targetCapacityPercent: 100\n})\n\ncluster.addAsgCapacityProvider(capacityProvider)\n```\n\n#### Defining the app service\n\nNow we are ready to define the service which will contain the task. I am setting the `minHealthyPercent` to `0` so that the service will not wait for the instances to be healthy before starting the deployment. And I am setting the `capacityProviderStrategies` to use the capacity provider which we defined earlier.\n\n```ts\nconst service = new Ec2Service(this, \"AppService\", {\n  taskDefinition,\n  cluster,\n  desiredCount: 1,\n  minHealthyPercent: 0,\n  capacityProviderStrategies: [\n    {\n      capacityProvider: capacityProvider.capacityProviderName,\n      weight: 1,\n      base: 0\n    }\n  ]\n})\n```\n\n#### Defining the container\n\nNow we are ready to define the container where the task will be running, Here I am\nusing `ContainerImage.fromAsset` to build the image from the local directory. CDK will\nbuild the image locally and push it to ECR. I am also using `awsLogs` driver to push the logs to CloudWatch. And I am setting the `memoryReservationMiB` to `200` so that the container will have a minimum of 200MB of memory. This amount can be changed based on the\nrequirements of the application. This value will be taken into consideration when scaling the app. And I am also mapping port `3000` of the container to port `3000` of the host. As NextJS is by default running on port `3000`.\n\n```ts\nconst container = taskDefinition.addContainer(\"AppContainer\", {\n  linuxParameters: new LinuxParameters(this, \"AppLinuxParams\"),\n  image: ContainerImage.fromAsset(\"../app\"),\n  logging: LogDriver.awsLogs({\n    streamPrefix: \"app\",\n    logRetention: RetentionDays.ONE_WEEK\n  }),\n  environment: {\n    NODE_ENV: \"production\"\n  },\n  memoryReservationMiB: 200\n})\n\ncontainer.addPortMappings({\n  containerPort: 3000,\n  hostPort: 3000,\n  protocol: ECSProtocol.TCP\n})\n```\n\n### HTTP certificate\n\nNow we have to have a certificate for the domain which we are going to use. This certificate will be used by the load balancer to serve the traffic over HTTPS. Make sure you create this certificate in the `us-east-1` region. This is a requirement for the load balancer.\n\nAs we are not in the `us-east-1` region, we have to import the certificate using the `Certificate.fromCertificateArn` method. You can copy the ARN of the certificate from the AWS console. I am setting the `APP_CERTIFICATE_ARN` environment variable to the ARN of the certificate.\n\n```ts\nconst domainCertificate = Certificate.fromCertificateArn(this, \"AppCertificate\", process.env.APP_CERTIFICATE_ARN!)\n```\n\n### Defining the load balancer\n\nNow we are ready to define the load balancer,\n\n```ts\nconst loadBalancer = new ApplicationLoadBalancer(this, \"AppLoadBalancer\", {\n  vpc,\n  internetFacing: true,\n  vpcSubnets: { subnetType: SubnetType.PUBLIC }\n})\n```\n\n##### Redirecting HTTP to HTTPS\n\nWe will redirect the HTTP traffic to HTTPS. This is done by adding a redirect rule to the load balancer. This will redirect all the traffic coming from port `80` to port `443` over HTTPS.\n\n```ts\nloadBalancer.addRedirect({\n  sourcePort: 80,\n  sourceProtocol: ApplicationProtocol.HTTP,\n  targetPort: 443,\n  targetProtocol: ApplicationProtocol.HTTPS\n})\n```\n\n##### Allow egress traffic\n\nWe have to allow the load balancer to make requests to the internet. This is done by adding a security group rule to the load balancer.\n\n```ts\nloadBalancer.connections.allowToAnyIpv4(Port.allTcp(), \"All Out\")\n```\n\n##### Connecting the load balancer to the app\n\nNow we are ready to connect the load balancer to the app.\nFirst, we will create a listener on port 443 and add the certificate which we created earlier.\nThen we can add the app service as a target to the listener.\n\nAns we also have to make sure the load balancer can be accessed from the internet. This can be done\nusing `allowFromAnyIpv4` method for ports `80` and `443`.\n\nFinally, we will allow the load balancer to make requests to the app on port `3000`.\n\n```ts\nconst listener = loadBalancer.addListener(\"AutomateListener\", {\n  port: 443,\n  certificates: [domainCertificate],\n  protocol: ApplicationProtocol.HTTPS\n})\n\nlistener.addTargets(\"AppTarget\", {\n  healthCheck: {\n    enabled: true,\n    protocol: Protocol.HTTP\n  },\n  port: 3000,\n  deregistrationDelay: Duration.seconds(3) as any,\n  protocol: ApplicationProtocol.HTTP,\n  targets: [service]\n})\n\nloadBalancer.connections.allowFromAnyIpv4(Port.tcp(80), \"Ingress HTTP internet\")\nloadBalancer.connections.allowFromAnyIpv4(Port.tcp(443), \"Ingress HTTPS internet\")\n\nfor (const subnet of vpc.publicSubnets as any) {\n  asg.connections.allowFrom(Peer.ipv4(subnet.ipv4CidrBlock), Port.tcp(3000), \"Ingress from ALB to App\")\n}\n```\n\n### Hosted zone and subdomain\n\nAs my domain is handled by AWS, I will add the subdomain to the hosted zone also here, If this is not the case for you, you can skip this step and directly point the domain to the load balancer's public IP which you can find after the deployment is done in the AWS console.\n\n```ts\nconst hostedZone = PublicHostedZone.fromLookup(this, \"HostedZone\", {\n  domainName: \"\u003csome-domain\u003e.com\"\n})\n\nnew ARecord(this, \"AppARecord\", {\n  zone: hostedZone,\n  target: RecordTarget.fromAlias(new LoadBalancerTarget(loadBalancer as any)),\n  recordName: \"app\"\n})\n```\n\n### Deploying the app,\n\nNow our infrastructure definition is ready to go.\nBefore deploying, we have to bootstrap the application, Before that, we have to make sure we have\nthe AWS credentials are set in the environment variables. And also make sure the `AWS_ACCOUNT_ID`\nand `APP_CERTIFICATE_ARN` environment variables are set.\n\n```sh\n# For bash:\nexport AWS_ACCOUNT_ID=\"\u003cAWS_ACCOUNT_ID\u003e\"\nexport AWS_ACCESS_KEY_ID=\"\u003cAWS_ACCESS_KEY_ID\u003e\"\nexport AWS_SECRET_ACCESS_KEY=\"\u003cAWS_SECRET_ACCESS_KEY\u003e\"\nexport AWS_DEFAULT_REGION=\"\u003cREGION\u003e\"\nexport APP_CERTIFICATE_ARN=\"arn:aws:acm:...\"\n```\n\nNow we can run the below command inside the `infra` folder to bootstrap the app,\n\n```sh\nnpx aws-cdk bootstrap\n```\n\n\u003cimg src=\"$$base_url/post-data/2023-02-15-deploying-react-app-on-ecs/cdk-bootstrap-result.jpg\" /\u003e\n\nAnd finally, we can deploy the app using the below command, This will take some time because it has to build the app image and push that to the ECR registry. I am doing this completely from the local machine but the steps are the same if you are using a CI/CD pipeline.\n\nAlso, make sure Docker is running on your machine as the CDK will use the local Docker daemon to build the image.\n\n```sh\nnpx aws-cdk deploy\n```\n\nOnce the deployment is complete, It should return an output like below,\n\n\u003cimg src=\"$$base_url/post-data/2023-02-15-deploying-react-app-on-ecs/cdk-deploy-result.png\" /\u003e\n\nNow you should see the stack is created in the Cloudfomration console.\n\n\u003cimg src=\"$$base_url/post-data/2023-02-15-deploying-react-app-on-ecs/cloudformation-console.png\" /\u003e\n\n### Testing the app\n\nNow we can test the app by visiting the domain which you used.\n\n\u003cimg src=\"$$base_url/post-data/2023-02-15-deploying-react-app-on-ecs/app.png\" /\u003e\n\nNow, If you increase the number of desired tasks for the service, The auto-scaling group will automatically facilitate the scaling by creating new instances.\n\n### Troubleshooting\n\nIf you get the error `The runtime parameter of python3.6 is no longer supported for creating or updating AWS Lambda functions. We recommend you use the new runtime (python3.9)`,\n\nRemove the `aws-cdk` package from the `package.json` file set the version for the package `aws-cdk-lib` to `^2.61.1`, install packages and run deploy again.\n\n### Source code\n\nYou can find the source code for this blog post [here](https://github.com/rusith/2023-02-15-deploying-react-app-on-ecs)\n","parsedContent":"\u003cp\u003e\u003cimg alt=\"Page banner\" class=\"Post_banner__soX4H\" src=\"https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/banner.png\"\u003e\u003c/p\u003e\n\u003cp\u003eIn this article, I am trying to demonstrate the steps to get an application running on AWS ECS with load-balancing and auto-scaling enabled using CDK. We will be writing the CDK code using TypeScript\u003c/p\u003e\n\u003cp\u003eI am choosing NextJS to build this application, mainly because NextJS is a full-stack framework and it makes sense to enable auto-scaling on such an application. but this could be any app/API. which has an endpoint that returns some HTML.\u003c/p\u003e\n\u003ch3 id=\"rootfolderstructure\"\u003eRoot folder Structure\u003c/h3\u003e\n\u003cp\u003eLet's first define the basic folder structure of this project, We will have the folder \u003ccode\u003eapp\u003c/code\u003e\nwhich will contain our application code and the \u003ccode\u003einfra\u003c/code\u003e folder will contain the infrastructure definition\nthat we are going to write using CDK.\u003c/p\u003e\n\u003ch3 id=\"creatingtheapplication\"\u003eCreating the application\u003c/h3\u003e\n\u003cp\u003eAs I previously mentioned, I am going to use NextJS to write my application\nAnd I will not do any changes to the NextJS boilerplate code\nas it is not important what the application does at this moment.\u003c/p\u003e\n\u003cp\u003eLet's first initialize a new NextJS app inside the \u003ccode\u003eapp\u003c/code\u003e directory by running the below command inside the \u003ccode\u003eapp\u003c/code\u003e directory.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs sh language-sh\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecd\u003c/span\u003e app \u0026amp;\u0026amp; npx create-next-app@latest --typescript .\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhich will result in a folder structure like this:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/folder-structure-1.png\" /\u003e\u003c/p\u003e\n\u003ch3 id=\"containerizetheapplication\"\u003eContainerize the application\u003c/h3\u003e\n\u003cp\u003eNow we have our application, we have to dockerize it in order to deploy it using CDK.\nWe can dockerize a NextJS application by creating a \u003ccode\u003eDockerfile\u003c/code\u003e inside the \u003ccode\u003eapp\u003c/code\u003e folder\u003c/p\u003e\n\u003cp\u003eThis is a simple \u003ccode\u003eDockerfile\u003c/code\u003e that we can use to dockerize our application, but you can change it based on your requirements.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs Dockerfile language-Dockerfile\"\u003e\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e node:\u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e-alpine\n\u003cspan class=\"hljs-keyword\"\u003eEXPOSE\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"language-bash\"\u003e \u003cspan class=\"hljs-built_in\"\u003emkdir\u003c/span\u003e /app\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eWORKDIR\u003c/span\u003e\u003cspan class=\"language-bash\"\u003e /app\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eCOPY\u003c/span\u003e\u003cspan class=\"language-bash\"\u003e . /app\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"language-bash\"\u003e yarn install\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eENV\u003c/span\u003e NODE_ENV=production\n\n\u003cspan class=\"hljs-keyword\"\u003eRUN\u003c/span\u003e\u003cspan class=\"language-bash\"\u003e yarn build\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eCMD\u003c/span\u003e\u003cspan class=\"language-bash\"\u003e [\u003cspan class=\"hljs-string\"\u003e\u0026quot;yarn\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;start\u0026quot;\u003c/span\u003e]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we are ready from the app side.\u003c/p\u003e\n\u003ch3 id=\"initializingthecdkapplication\"\u003eInitializing the CDK application\u003c/h3\u003e\n\u003cp\u003eTo initialize the CDK application, we have to run the below command inside the \u003ccode\u003einfra\u003c/code\u003e\ndirectory. This will generate the code necessary to get started with defining\nthe infrastructure of the project.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs sh language-sh\"\u003ecdk init app --language typescript .\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe new folder structure inside \u003ccode\u003einfra\u003c/code\u003e folder will look like this\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/folder-structure-2.png\" /\u003e\u003c/p\u003e\n\u003cp\u003eNow, let's change the content of the \u003ccode\u003ebin/infra.ts\u003c/code\u003e file to the code below,\nThis is the entry point of the CDK application. We are initializing the \u003ccode\u003eInfraStack\u003c/code\u003e which\nwe import from \u003ccode\u003elib\u003c/code\u003e folder.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs ts language-ts\"\u003e\u003cspan class=\"hljs-meta\"\u003e#!/usr/bin/env node\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;source-map-support/register\u0026quot;\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e cdk \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;aws-cdk-lib\u0026quot;\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eInfraStack\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;../lib/infra-stack\u0026quot;\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e cdk.\u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInfraStack\u003c/span\u003e(app, \u003cspan class=\"hljs-string\"\u003e\u0026quot;InfraStack\u0026quot;\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"definingtheinfrastructure\"\u003eDefining the infrastructure\u003c/h3\u003e\n\u003cp\u003eNow we are ready to define the infrastructure of the project. To make it easier, I will only have one file\nwhich is \u003ccode\u003elib/infra-stack.ts\u003c/code\u003e and I will define all the resources in this file. But it is a good practice to\nbreak the infrastructure into multiple files and import them in the \u003ccode\u003einfra-stack.ts\u003c/code\u003e file.\u003c/p\u003e\n\u003cp\u003eAs the initial step, let's change \u003ccode\u003elib/infra-stack.ts\u003c/code\u003e file,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs ts language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eStack\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eStackProps\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;aws-cdk-lib\u0026quot;\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eConstruct\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;constructs\u0026quot;\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInfraStack\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStack\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003escope: Construct, id: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e, props?: StackProps\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e(scope, id, {\n      \u003cspan class=\"hljs-attr\"\u003eenv\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003eaccount\u003c/span\u003e: process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eAWS_ACCOUNT_ID\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003eregion\u003c/span\u003e: process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eAWS_DEFAULT_REGION\u003c/span\u003e\n      }\n    })\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere we are initializing the stack and setting the \u003ccode\u003eaccount\u003c/code\u003e and \u003ccode\u003eregion\u003c/code\u003e from the environment variables.\nHaving the \u003ccode\u003eaccount\u003c/code\u003e and \u003ccode\u003eregion\u003c/code\u003e is required to deploy the stack.\u003c/p\u003e\n\u003ch4 id=\"definingthevpc\"\u003eDefining the VPC\u003c/h4\u003e\n\u003cp\u003eLet's start by creating a VPC for our application. All other resources will be created inside this VPC.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs ts language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e vpc = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eVpc\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;AppVPC\u0026quot;\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003enatGateways\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"definingtheecscluster\"\u003eDefining the ECS cluster\u003c/h4\u003e\n\u003cp\u003eNow we have to define an ECS cluster that contains all resources related to our ECS.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs ts language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e cluster = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCluster\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;Cluster\u0026quot;\u003c/span\u003e, { vpc })\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"definingapptask\"\u003eDefining app task\u003c/h4\u003e\n\u003cp\u003eBefore defining the task, we have to define a role for the task.\nThis role has to be based on the \u003ccode\u003eecs-tasks.amazonaws.com\u003c/code\u003e role.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs ts language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e taskRole = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRole\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;AppRole\u0026quot;\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003eassumedBy\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eServicePrincipal\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;ecs-tasks.amazonaws.com\u0026quot;\u003c/span\u003e)\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we have to add required permissions to the role,\nThese permissions could change based on the requirements of the project.\nFor this project, we are going to add permissions for \u003ccode\u003elog\u003c/code\u003e and \u003ccode\u003eCloudWatch\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs ts language-ts\"\u003etaskRole.\u003cspan class=\"hljs-title function_\"\u003eaddToPolicy\u003c/span\u003e(\n  \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePolicyStatement\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eresources\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\u0026quot;*\u0026quot;\u003c/span\u003e],\n    \u003cspan class=\"hljs-attr\"\u003eactions\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\u0026quot;logs:*\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;cloudwatch:*\u0026quot;\u003c/span\u003e]\n  })\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we are ready to define the task. The task is the basic unit that runs on the actual container. As we are targeting EC2, we have to define the \u003ccode\u003ecompatibility\u003c/code\u003e as \u003ccode\u003eEC2\u003c/code\u003e. And \u003ccode\u003eobtainExecutionRole\u003c/code\u003e will create the execution role for this task if it does not exist.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs ts language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e taskDefinition = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaskDefinition\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;AppTask\u0026quot;\u003c/span\u003e, {\n  taskRole,\n  \u003cspan class=\"hljs-attr\"\u003ecompatibility\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCompatibility\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eEC2\u003c/span\u003e\n})\ntaskDefinition.\u003cspan class=\"hljs-title function_\"\u003eobtainExecutionRole\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"definingtheautoscalinggroup\"\u003eDefining the auto-scaling group\u003c/h4\u003e\n\u003cp\u003eNow we have to define an auto-scaling group that will handle the\ncreation and destruction of the EC2 instances. based on the\nrequirements of the capacity provider which will be defined later.\nHere I am using a \u003ccode\u003et3.nano\u003c/code\u003e instance type, this can be changed based on the requirements. And I am setting the \u003ccode\u003edesiredCapacity\u003c/code\u003e to \u003ccode\u003e0\u003c/code\u003e so that no instances will be created at the beginning.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs ts language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e asg = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAutoScalingGroup\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;ASG\u0026quot;\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003einstanceType\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInstanceType\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;t3.nano\u0026quot;\u003c/span\u003e),\n  \u003cspan class=\"hljs-attr\"\u003emachineImage\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eEcsOptimizedImage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eamazonLinux2\u003c/span\u003e(),\n  \u003cspan class=\"hljs-attr\"\u003eassociatePublicIpAddress\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003emaxCapacity\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003edesiredCapacity\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eminCapacity\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003evpc\u003c/span\u003e: vpc,\n  \u003cspan class=\"hljs-attr\"\u003evpcSubnets\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003esubnetType\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSubnetType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePUBLIC\u003c/span\u003e },\n  \u003cspan class=\"hljs-attr\"\u003enewInstancesProtectedFromScaleIn\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"definingthecapacityprovider\"\u003eDefining the capacity provider\u003c/h4\u003e\n\u003cp\u003eWe are going to use the capacity provider to connect the auto-scaling group and the ECS cluster. This will handle all the scaling scenarios. I am setting the \u003ccode\u003eenableManagedScaling\u003c/code\u003e to \u003ccode\u003etrue\u003c/code\u003e so that the capacity provider will handle the scaling of the instances. And I am setting the \u003ccode\u003etargetCapacityPercent\u003c/code\u003e to \u003ccode\u003e100\u003c/code\u003e so that the capacity provider will always try to keep the instances at 100% capacity and will not create additional instances. It's also important to note, by setting the \u003ccode\u003eenableManagedTerminationProtection\u003c/code\u003e to \u003ccode\u003efalse\u003c/code\u003e we are allowing the capacity provider to terminate the instances if it is required.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs ts language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e capacityProvider = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAsgCapacityProvider\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;EC2CapacityProvider\u0026quot;\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003eautoScalingGroup\u003c/span\u003e: asg,\n  \u003cspan class=\"hljs-attr\"\u003eenableManagedScaling\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eenableManagedTerminationProtection\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etargetCapacityPercent\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e\n})\n\ncluster.\u003cspan class=\"hljs-title function_\"\u003eaddAsgCapacityProvider\u003c/span\u003e(capacityProvider)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"definingtheappservice\"\u003eDefining the app service\u003c/h4\u003e\n\u003cp\u003eNow we are ready to define the service which will contain the task. I am setting the \u003ccode\u003eminHealthyPercent\u003c/code\u003e to \u003ccode\u003e0\u003c/code\u003e so that the service will not wait for the instances to be healthy before starting the deployment. And I am setting the \u003ccode\u003ecapacityProviderStrategies\u003c/code\u003e to use the capacity provider which we defined earlier.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs ts language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e service = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEc2Service\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;AppService\u0026quot;\u003c/span\u003e, {\n  taskDefinition,\n  cluster,\n  \u003cspan class=\"hljs-attr\"\u003edesiredCount\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eminHealthyPercent\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ecapacityProviderStrategies\u003c/span\u003e: [\n    {\n      \u003cspan class=\"hljs-attr\"\u003ecapacityProvider\u003c/span\u003e: capacityProvider.\u003cspan class=\"hljs-property\"\u003ecapacityProviderName\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eweight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003ebase\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n    }\n  ]\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"definingthecontainer\"\u003eDefining the container\u003c/h4\u003e\n\u003cp\u003eNow we are ready to define the container where the task will be running, Here I am\nusing \u003ccode\u003eContainerImage.fromAsset\u003c/code\u003e to build the image from the local directory. CDK will\nbuild the image locally and push it to ECR. I am also using \u003ccode\u003eawsLogs\u003c/code\u003e driver to push the logs to CloudWatch. And I am setting the \u003ccode\u003ememoryReservationMiB\u003c/code\u003e to \u003ccode\u003e200\u003c/code\u003e so that the container will have a minimum of 200MB of memory. This amount can be changed based on the\nrequirements of the application. This value will be taken into consideration when scaling the app. And I am also mapping port \u003ccode\u003e3000\u003c/code\u003e of the container to port \u003ccode\u003e3000\u003c/code\u003e of the host. As NextJS is by default running on port \u003ccode\u003e3000\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs ts language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container = taskDefinition.\u003cspan class=\"hljs-title function_\"\u003eaddContainer\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;AppContainer\u0026quot;\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003elinuxParameters\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLinuxParameters\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;AppLinuxParams\u0026quot;\u003c/span\u003e),\n  \u003cspan class=\"hljs-attr\"\u003eimage\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eContainerImage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efromAsset\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;../app\u0026quot;\u003c/span\u003e),\n  \u003cspan class=\"hljs-attr\"\u003elogging\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eLogDriver\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eawsLogs\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003estreamPrefix\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;app\u0026quot;\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003elogRetention\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eRetentionDays\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eONE_WEEK\u003c/span\u003e\n  }),\n  \u003cspan class=\"hljs-attr\"\u003eenvironment\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eNODE_ENV\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;production\u0026quot;\u003c/span\u003e\n  },\n  \u003cspan class=\"hljs-attr\"\u003ememoryReservationMiB\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e\n})\n\ncontainer.\u003cspan class=\"hljs-title function_\"\u003eaddPortMappings\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003econtainerPort\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ehostPort\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eprotocol\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eECSProtocol\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eTCP\u003c/span\u003e\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"httpcertificate\"\u003eHTTP certificate\u003c/h3\u003e\n\u003cp\u003eNow we have to have a certificate for the domain which we are going to use. This certificate will be used by the load balancer to serve the traffic over HTTPS. Make sure you create this certificate in the \u003ccode\u003eus-east-1\u003c/code\u003e region. This is a requirement for the load balancer.\u003c/p\u003e\n\u003cp\u003eAs we are not in the \u003ccode\u003eus-east-1\u003c/code\u003e region, we have to import the certificate using the \u003ccode\u003eCertificate.fromCertificateArn\u003c/code\u003e method. You can copy the ARN of the certificate from the AWS console. I am setting the \u003ccode\u003eAPP_CERTIFICATE_ARN\u003c/code\u003e environment variable to the ARN of the certificate.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs ts language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e domainCertificate = \u003cspan class=\"hljs-title class_\"\u003eCertificate\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efromCertificateArn\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;AppCertificate\u0026quot;\u003c/span\u003e, process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eAPP_CERTIFICATE_ARN\u003c/span\u003e!)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"definingtheloadbalancer\"\u003eDefining the load balancer\u003c/h3\u003e\n\u003cp\u003eNow we are ready to define the load balancer,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs ts language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e loadBalancer = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApplicationLoadBalancer\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;AppLoadBalancer\u0026quot;\u003c/span\u003e, {\n  vpc,\n  \u003cspan class=\"hljs-attr\"\u003einternetFacing\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003evpcSubnets\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003esubnetType\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSubnetType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePUBLIC\u003c/span\u003e }\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5 id=\"redirectinghttptohttps\"\u003eRedirecting HTTP to HTTPS\u003c/h5\u003e\n\u003cp\u003eWe will redirect the HTTP traffic to HTTPS. This is done by adding a redirect rule to the load balancer. This will redirect all the traffic coming from port \u003ccode\u003e80\u003c/code\u003e to port \u003ccode\u003e443\u003c/code\u003e over HTTPS.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs ts language-ts\"\u003eloadBalancer.\u003cspan class=\"hljs-title function_\"\u003eaddRedirect\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003esourcePort\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003esourceProtocol\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eApplicationProtocol\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eHTTP\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etargetPort\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e443\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etargetProtocol\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eApplicationProtocol\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eHTTPS\u003c/span\u003e\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5 id=\"allowegresstraffic\"\u003eAllow egress traffic\u003c/h5\u003e\n\u003cp\u003eWe have to allow the load balancer to make requests to the internet. This is done by adding a security group rule to the load balancer.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs ts language-ts\"\u003eloadBalancer.\u003cspan class=\"hljs-property\"\u003econnections\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eallowToAnyIpv4\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003ePort\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eallTcp\u003c/span\u003e(), \u003cspan class=\"hljs-string\"\u003e\u0026quot;All Out\u0026quot;\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5 id=\"connectingtheloadbalancertotheapp\"\u003eConnecting the load balancer to the app\u003c/h5\u003e\n\u003cp\u003eNow we are ready to connect the load balancer to the app.\nFirst, we will create a listener on port 443 and add the certificate which we created earlier.\nThen we can add the app service as a target to the listener.\u003c/p\u003e\n\u003cp\u003eAns we also have to make sure the load balancer can be accessed from the internet. This can be done\nusing \u003ccode\u003eallowFromAnyIpv4\u003c/code\u003e method for ports \u003ccode\u003e80\u003c/code\u003e and \u003ccode\u003e443\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFinally, we will allow the load balancer to make requests to the app on port \u003ccode\u003e3000\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs ts language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e listener = loadBalancer.\u003cspan class=\"hljs-title function_\"\u003eaddListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;AutomateListener\u0026quot;\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003eport\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e443\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ecertificates\u003c/span\u003e: [domainCertificate],\n  \u003cspan class=\"hljs-attr\"\u003eprotocol\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eApplicationProtocol\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eHTTPS\u003c/span\u003e\n})\n\nlistener.\u003cspan class=\"hljs-title function_\"\u003eaddTargets\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;AppTarget\u0026quot;\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003ehealthCheck\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eenabled\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eprotocol\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eProtocol\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eHTTP\u003c/span\u003e\n  },\n  \u003cspan class=\"hljs-attr\"\u003eport\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ederegistrationDelay\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eseconds\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eprotocol\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eApplicationProtocol\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eHTTP\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etargets\u003c/span\u003e: [service]\n})\n\nloadBalancer.\u003cspan class=\"hljs-property\"\u003econnections\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eallowFromAnyIpv4\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003ePort\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etcp\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e), \u003cspan class=\"hljs-string\"\u003e\u0026quot;Ingress HTTP internet\u0026quot;\u003c/span\u003e)\nloadBalancer.\u003cspan class=\"hljs-property\"\u003econnections\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eallowFromAnyIpv4\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003ePort\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etcp\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e443\u003c/span\u003e), \u003cspan class=\"hljs-string\"\u003e\u0026quot;Ingress HTTPS internet\u0026quot;\u003c/span\u003e)\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e subnet \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e vpc.\u003cspan class=\"hljs-property\"\u003epublicSubnets\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e) {\n  asg.\u003cspan class=\"hljs-property\"\u003econnections\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eallowFrom\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003ePeer\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eipv4\u003c/span\u003e(subnet.\u003cspan class=\"hljs-property\"\u003eipv4CidrBlock\u003c/span\u003e), \u003cspan class=\"hljs-title class_\"\u003ePort\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etcp\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e), \u003cspan class=\"hljs-string\"\u003e\u0026quot;Ingress from ALB to App\u0026quot;\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"hostedzoneandsubdomain\"\u003eHosted zone and subdomain\u003c/h3\u003e\n\u003cp\u003eAs my domain is handled by AWS, I will add the subdomain to the hosted zone also here, If this is not the case for you, you can skip this step and directly point the domain to the load balancer's public IP which you can find after the deployment is done in the AWS console.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs ts language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hostedZone = \u003cspan class=\"hljs-title class_\"\u003ePublicHostedZone\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efromLookup\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;HostedZone\u0026quot;\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003edomainName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026lt;some-domain\u0026gt;.com\u0026quot;\u003c/span\u003e\n})\n\n\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eARecord\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;AppARecord\u0026quot;\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003ezone\u003c/span\u003e: hostedZone,\n  \u003cspan class=\"hljs-attr\"\u003etarget\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eRecordTarget\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efromAlias\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLoadBalancerTarget\u003c/span\u003e(loadBalancer \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e)),\n  \u003cspan class=\"hljs-attr\"\u003erecordName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;app\u0026quot;\u003c/span\u003e\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"deployingtheapp\"\u003eDeploying the app,\u003c/h3\u003e\n\u003cp\u003eNow our infrastructure definition is ready to go.\nBefore deploying, we have to bootstrap the application, Before that, we have to make sure we have\nthe AWS credentials are set in the environment variables. And also make sure the \u003ccode\u003eAWS_ACCOUNT_ID\u003c/code\u003e\nand \u003ccode\u003eAPP_CERTIFICATE_ARN\u003c/code\u003e environment variables are set.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs sh language-sh\"\u003e\u003cspan class=\"hljs-comment\"\u003e# For bash:\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eexport\u003c/span\u003e AWS_ACCOUNT_ID=\u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026lt;AWS_ACCOUNT_ID\u0026gt;\u0026quot;\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eexport\u003c/span\u003e AWS_ACCESS_KEY_ID=\u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026lt;AWS_ACCESS_KEY_ID\u0026gt;\u0026quot;\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eexport\u003c/span\u003e AWS_SECRET_ACCESS_KEY=\u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026lt;AWS_SECRET_ACCESS_KEY\u0026gt;\u0026quot;\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eexport\u003c/span\u003e AWS_DEFAULT_REGION=\u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026lt;REGION\u0026gt;\u0026quot;\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eexport\u003c/span\u003e APP_CERTIFICATE_ARN=\u003cspan class=\"hljs-string\"\u003e\u0026quot;arn:aws:acm:...\u0026quot;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we can run the below command inside the \u003ccode\u003einfra\u003c/code\u003e folder to bootstrap the app,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs sh language-sh\"\u003enpx aws-cdk bootstrap\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/cdk-bootstrap-result.jpg\" /\u003e\u003c/p\u003e\n\u003cp\u003eAnd finally, we can deploy the app using the below command, This will take some time because it has to build the app image and push that to the ECR registry. I am doing this completely from the local machine but the steps are the same if you are using a CI/CD pipeline.\u003c/p\u003e\n\u003cp\u003eAlso, make sure Docker is running on your machine as the CDK will use the local Docker daemon to build the image.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs sh language-sh\"\u003enpx aws-cdk deploy\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOnce the deployment is complete, It should return an output like below,\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/cdk-deploy-result.png\" /\u003e\u003c/p\u003e\n\u003cp\u003eNow you should see the stack is created in the Cloudfomration console.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/cloudformation-console.png\" /\u003e\u003c/p\u003e\n\u003ch3 id=\"testingtheapp\"\u003eTesting the app\u003c/h3\u003e\n\u003cp\u003eNow we can test the app by visiting the domain which you used.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/app.png\" /\u003e\u003c/p\u003e\n\u003cp\u003eNow, If you increase the number of desired tasks for the service, The auto-scaling group will automatically facilitate the scaling by creating new instances.\u003c/p\u003e\n\u003ch3 id=\"troubleshooting\"\u003eTroubleshooting\u003c/h3\u003e\n\u003cp\u003eIf you get the error \u003ccode\u003eThe runtime parameter of python3.6 is no longer supported for creating or updating AWS Lambda functions. We recommend you use the new runtime (python3.9)\u003c/code\u003e,\u003c/p\u003e\n\u003cp\u003eRemove the \u003ccode\u003eaws-cdk\u003c/code\u003e package from the \u003ccode\u003epackage.json\u003c/code\u003e file set the version for the package \u003ccode\u003eaws-cdk-lib\u003c/code\u003e to \u003ccode\u003e^2.61.1\u003c/code\u003e, install packages and run deploy again.\u003c/p\u003e\n\u003ch3 id=\"sourcecode\"\u003eSource code\u003c/h3\u003e\n\u003cp\u003eYou can find the source code for this blog post \u003ca href=\"https://github.com/rusith/2023-02-15-deploying-react-app-on-ecs\"\u003ehere\u003c/a\u003e\u003c/p\u003e"},"page":"Post","topTags":["programming","aws","web","machineLearning","react","javascript","dataScience","typescript","r","csharp"],"relatedPosts":[{"title":"Testing Redux Connected React Components Using Jest","tags":["programming","javascript","react","redux","testing","jest"],"fullUrl":"https://rusith.me/blog/testing-react-redux-connected-components-using-jest","date":"Mon, Apr 27, 2020","description":"Testing React components connected to a Redux store using Jest and React Testing Library.","banner":"/post-data/2020-04-27-testing-redux-connect/banner.png"},{"title":"Running a Nuget Feed on S3 with Automated Deployments","tags":["programming","dotnet","s3","aws","nuget"],"fullUrl":"https://rusith.me/blog/nuget-feed-on-s3","date":"Sat, Nov 2, 2019","description":"There are many ways of creating a Nuget feed. but did you know that you can run a Nuget feed on S3 without any computing infrastructure? In this post, I will show you how you can create a Nuget feed on S3 using Sleet and automate the deployment process for packages.","banner":"/post-data/2019-11-03-nuget-feed-s3/banner.png"},{"title":"Deploying a Website on S3 With SSL, Continuous Integration","tags":["aws","programming","web"],"fullUrl":"https://rusith.me/blog/building-a-website-on-s3","date":"Mon, Aug 5, 2019","description":"In this post, I am creating a website and host it on S3 and setup a continuous integration pipeline setup using Gitlab","banner":"/post-data/2019-08-14-building-a-website-on-s3/banner.png"}]},"__N_SSG":true},"page":"/[[...path]]","query":{"path":["blog","deploy-app-on-aws-ecs-with-cdk-auto-scaling-and-load-balancing"]},"buildId":"PaoTT2YDvwYY_jbobaNoC","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>