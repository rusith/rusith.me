{"pageProps":{"post":{"fileName":"2018-03-20-genie-an-efficient-way-to-access-data.md","fullPath":"/home/runner/work/rusith.me/rusith.me/modules/blog/posts/2018-03-20-genie-an-efficient-way-to-access-data.md","title":"Genie - An Efficient Way to Access Data","tags":["programming","csharp","genie","rdbms"],"comments":true,"description":"Almost all the time we need a database to run our apps. most of the time, these databases are relational databases. as everyone knows we must use SQL to access these databases. writing an SQL query for every database call is a pain and no one does that these days. instead, we use something called ORMs (Object Relational Mappers). we can use an ORM to access databases without writing SQL or worrying about mapping relations to objects. there are a lot of ORM implementations for every popular language.","dateCreated":"Thu Mar 15 2018 00:00:00 GMT+0000 (Coordinated Universal Time)","dateModified":"Thu Mar 15 2018 00:00:00 GMT+0000 (Coordinated Universal Time)","datePublished":"Thu Mar 15 2018 00:00:00 GMT+0000 (Coordinated Universal Time)","dependencies":".Net","about":"Accessing data on a realational database using Genie","path":"/blog/genie-an-efficient-way-to-access-data","oldPath":"/2018/03/20/genie-an-efficient-way-to-access-data","dateCreatedFormatted":"Thu, Mar 15, 2018","fullUrl":"https://rusith.me/blog/genie-an-efficient-way-to-access-data","fileContent":"---\ntitle: Genie - An Efficient Way to Access Data\ntags: programming csharp genie rdbms\ncomments: true\ndescription: Almost all the time we need a database to run our apps. most of the time, these databases are relational databases. as everyone knows we must use SQL to access these databases. writing an SQL query for every database call is a pain and no one does that these days. instead, we use something called ORMs (Object Relational Mappers). we can use an ORM to access databases without writing SQL or worrying about mapping relations to objects. there are a lot of ORM implementations for every popular language.\ndateCreated: 2018-03-15\ndateModified: 2018-03-15\ndatePublished: 2018-03-15\ndependencies: .Net\nabout: Accessing data on a realational database using Genie\npath: /genie-an-efficient-way-to-access-data\noldPath: /2018/03/20/genie-an-efficient-way-to-access-data\n---\n\nAlmost all the time we need a database to run our apps. most of the time, these databases are relational databases. as everyone knows we must use SQL to access these databases. writing an SQL query for every database call is a pain and no one does that these days. instead, we use something called ORMs (Object Relational Mappers). we can use an ORM to access databases without writing SQL or worrying about mapping relations to objects. there are a lot of ORM implementations for every popular language.\n\nGenie is a simple code generator which generates an ORM with all essential functionalities for you. You can use Genie to create a dot Net class library and use it as a layer between your data source and application. usually, this type of implementation is called a Data Access Layer as it provides an API to access a database. You can write your database logic in this layer. and the code generated by Genie will help you to do that.\n\n## Installing Genie\n\nGenie is a free and open source software. you can download the latest release for Linux/ Windows or Mac from [here](https://github.com/Divicent/Genie)\n\nAfter downloading, extract the zip to some folder and add the path to the folder to the PATH global variable. for Linux users make the GenieCLI file executable by running the command `chmod +x GenieCLI`\n\n## Setting Up\n\nTo use Genie on a database you should create a configuration file. this configuration file specifies all the configuration that Genie needs to generate the code. For this demonstration, I will use a MySql database called bestappdata\n\n```json\n{\n  \"connectionString\":\n    \"Server=localhost;Database=bestappdata;UID=root;Password=password\",\n  \"projectPath\": \"/home/rusith/Documents/Projects/BestAppEver/BackEnd/BestAppEver.DAL\",\n  \"baseNamespace\": \"BestAppEver.DAL\",\n  \"ProjectFile\": \"BestAppEver.DAL.csproj\",\n  \"dbms\": \"mysql\",\n  \"schema\": \"animus\",\n  \"abstractModelsLocation\": \"./../BestAppEver/Models/Data\",\n  \"abstractModelsNamespace\": \"BestAppEver.Models.Data\"\n}\n```\n\nThis configuration file should be named as `genieSettings.json` and can put anywhere in your project. but its good to put this file inside the target library’s location. Genie uses this to fetch database metadata and generate the code. the `projectPath` is the full path to the project folder\n\nBelow is my folder structure for this demonstration. I have put my `genieSettings.json` file inside the `BestAppEver.DAL` folder.\n\n```\n├── BestAppEver\n│   ├── Modules\n├── BestAppEver.API\n│   ├── Controllers\n├── BestAppEver.BL\n│   ├── Services\n├── BestAppEver.DAL\n│   ├── Modules\n│   └── Providers\n└── BestAppEver.UnitTests\n|   ├── Providers\n├── bin\n│   └── Debug\n│       └── netstandard2.0\n├── Dapper\n├── Infrastructure\n│   ├── Actions\n│   │   ├── Abstract\n│   │   └── Concrete\n│   ├── Collections\n│   │   ├── Abstract\n│   │   └── Concrete\n│   ├── Enum\n│   ├── Filters\n│   │   ├── Abstract\n│   │   └── Concrete\n│   ├── Interfaces\n│   ├── Models\n│   │   ├── Abstract\n│   │   │   └── Context\n│   │   └── Concrete\n│   │       └── Context\n│   └── Repositories\n├── Modules\n├── obj\n│   └── Debug\n│       └── netstandard2.0\n└── Providers\n```\n\n## Generating the Code\n\ngo to the directory where the genieSettings.json file exists, run GenieCLI executable by executing GenieCLI in the terminal. we can do this because we have put Genie executable’s folder path to the path variable. otherwise you have to specify full path to the `GenieCLI` executable which is in the zip file you have downloaded.\n\nAfter generating , the BestAppEver.DAL folder will have two new root folders. Will look like below\n\n```\n├── Dapper\n├── Infrastructure\n│   ├── Actions\n│   │   ├── Abstract\n│   │   └── Concrete\n│   ├── Collections\n│   │   ├── Abstract\n│   │   └── Concrete\n│   ├── Enum\n│   ├── Filters\n│   │   ├── Abstract\n│   │   └── Concrete\n│   ├── Interfaces\n│   ├── Models\n│   │   ├── Abstract\n│   │   │   └── Context\n│   │   └── Concrete\n│   │       └── Context\n│   └── Repositories\n├── Modules\n└── Providers\n```\n\n## Writing Code\n\nIn order to continue, you need one thing. you have to implement the `IConnectionStringProvider` in order to user the `DBContext`. create a class for `IConnectionStringProvider` and pass an instance to the `DBContext` when ever needed.\n\n```cs\nusing BestAppEver.DAL.Infrastructure.Interfaces;\n\nnamespace BestAppEver.DAL\n{\n  public class ConnectionProvider : IConnectionStringProvider\n  {\n    public string GetConnectionString()\n    {\n      return \"Server=localhost;Database=bestappdata;UID=root;Password=password\"; // Should be taken from a configuration file \n    }\n  }\n}\n```\n\nYou should initialize `DBContext` only once .you should keep this instance in a global scope. for this demonstration i use .Net core DI to setup my dependencies.\n\n```cs\nusing BestAppEver.Injection;\nusing BestAppEver.DAL.Infrastructure.Interfaces;\nusing BestAppEver.DAL.Infrastructure;\n\nnamespace BestAppEver.DAL.Modules\n{\n  public class DataAccessModule : IModule\n  {\n    public void Bootstrap(IDependencyStore store)\n    {\n      store.Singleton<IConnectionStringProvider, ConnectionProvider>();\n      store.Singleton<IDBContext, DBContext>();\n    }\n  }\n}\n```\n\nI use providers to wrap my database code.\n\n```cs\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing BestAppEver.DAL.Infrastructure.Interfaces;\nusing BestAppEver.DAL.Infrastructure.Models.Concrete;\nusing BestAppEver.Models.Data;\nusing BestAppEver.Providers.Data;\n\nnamespace BestAppEver.DAL.Providers\n{\n  public class UserProvider : IUserProvider\n  {\n    private readonly IDBContext _context;\n    public UserProvider(IDBContext context)\n    {\n      _context = context;\n    }\n\n    public async Task Add(IUser user)\n    {\n      var unit = _context.Unit();\n      unit.UserRepository.Add(user);\n      await unit.CommitAsync();\n    }\n\n    public async Task<IUser> Get(int id)\n    {\n      var unit = _context.Unit();\n      return await unit.UserRepository.GetByKeyAsync(id);\n    }\n\n    public async IEnumerable<IUser> GetAll(int skip, int take, string serchText)\n    {\n      var getter = _context.Unit().UserRepository.Get();\n      if (!string.IsNullOrWhiteSpace(serchText))\n      {\n        getter.Where.FirstName.Contains(serchText)\n          .Or.LastName.Contains(serchText);\n      }\n\n      getter.Skip(skip).Take(take);\n\n      return await getter.QueryAsync();\n    }\n\n    public async Task<IUser> GetAsync(int id)\n    {\n      return await _context.Unit().UserRepository.GetByKeyAsync(id);\n    }\n\n    public async Task<IUser> getByEmail(string email)\n    {\n      return await _context.Unit().UserRepository.Get()\n        .Where.Email.EqualsTo(email).Filter().FirstOrDefaultAsync();\n    }\n\n    public async Task Update(IUser user)\n    {\n      await (user  as User).DatabaseUnitOfWork.CommitAsync();\n    }\n  }\n}\n```\n\nThis could have problems with some databases as this is in development and has only tested in Windows 10, Mac OSX Sierra, Ubuntu 16.04. You can contribute to the code through **GitHub**","parsedContent":"<p>Almost all the time we need a database to run our apps. most of the time, these databases are relational databases. as everyone knows we must use SQL to access these databases. writing an SQL query for every database call is a pain and no one does that these days. instead, we use something called ORMs (Object Relational Mappers). we can use an ORM to access databases without writing SQL or worrying about mapping relations to objects. there are a lot of ORM implementations for every popular language.</p>\n<p>Genie is a simple code generator which generates an ORM with all essential functionalities for you. You can use Genie to create a dot Net class library and use it as a layer between your data source and application. usually, this type of implementation is called a Data Access Layer as it provides an API to access a database. You can write your database logic in this layer. and the code generated by Genie will help you to do that.</p>\n<h2 id=\"installinggenie\">Installing Genie</h2>\n<p>Genie is a free and open source software. you can download the latest release for Linux/ Windows or Mac from <a href=\"https://github.com/Divicent/Genie\">here</a></p>\n<p>After downloading, extract the zip to some folder and add the path to the folder to the PATH global variable. for Linux users make the GenieCLI file executable by running the command <code>chmod +x GenieCLI</code></p>\n<h2 id=\"settingup\">Setting Up</h2>\n<p>To use Genie on a database you should create a configuration file. this configuration file specifies all the configuration that Genie needs to generate the code. For this demonstration, I will use a MySql database called bestappdata</p>\n<pre><code class=\"hljs json language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;connectionString&quot;</span><span class=\"hljs-punctuation\">:</span>\n    <span class=\"hljs-string\">&quot;Server=localhost;Database=bestappdata;UID=root;Password=password&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;projectPath&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;/home/rusith/Documents/Projects/BestAppEver/BackEnd/BestAppEver.DAL&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;baseNamespace&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;BestAppEver.DAL&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;ProjectFile&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;BestAppEver.DAL.csproj&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;dbms&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;mysql&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;schema&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;animus&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;abstractModelsLocation&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;./../BestAppEver/Models/Data&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;abstractModelsNamespace&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;BestAppEver.Models.Data&quot;</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>This configuration file should be named as <code>genieSettings.json</code> and can put anywhere in your project. but its good to put this file inside the target library’s location. Genie uses this to fetch database metadata and generate the code. the <code>projectPath</code> is the full path to the project folder</p>\n<p>Below is my folder structure for this demonstration. I have put my <code>genieSettings.json</code> file inside the <code>BestAppEver.DAL</code> folder.</p>\n<pre><code>├── BestAppEver\n│   ├── Modules\n├── BestAppEver.API\n│   ├── Controllers\n├── BestAppEver.BL\n│   ├── Services\n├── BestAppEver.DAL\n│   ├── Modules\n│   └── Providers\n└── BestAppEver.UnitTests\n|   ├── Providers\n├── bin\n│   └── Debug\n│       └── netstandard2.0\n├── Dapper\n├── Infrastructure\n│   ├── Actions\n│   │   ├── Abstract\n│   │   └── Concrete\n│   ├── Collections\n│   │   ├── Abstract\n│   │   └── Concrete\n│   ├── Enum\n│   ├── Filters\n│   │   ├── Abstract\n│   │   └── Concrete\n│   ├── Interfaces\n│   ├── Models\n│   │   ├── Abstract\n│   │   │   └── Context\n│   │   └── Concrete\n│   │       └── Context\n│   └── Repositories\n├── Modules\n├── obj\n│   └── Debug\n│       └── netstandard2.0\n└── Providers\n</code></pre>\n<h2 id=\"generatingthecode\">Generating the Code</h2>\n<p>go to the directory where the genieSettings.json file exists, run GenieCLI executable by executing GenieCLI in the terminal. we can do this because we have put Genie executable’s folder path to the path variable. otherwise you have to specify full path to the <code>GenieCLI</code> executable which is in the zip file you have downloaded.</p>\n<p>After generating , the BestAppEver.DAL folder will have two new root folders. Will look like below</p>\n<pre><code>├── Dapper\n├── Infrastructure\n│   ├── Actions\n│   │   ├── Abstract\n│   │   └── Concrete\n│   ├── Collections\n│   │   ├── Abstract\n│   │   └── Concrete\n│   ├── Enum\n│   ├── Filters\n│   │   ├── Abstract\n│   │   └── Concrete\n│   ├── Interfaces\n│   ├── Models\n│   │   ├── Abstract\n│   │   │   └── Context\n│   │   └── Concrete\n│   │       └── Context\n│   └── Repositories\n├── Modules\n└── Providers\n</code></pre>\n<h2 id=\"writingcode\">Writing Code</h2>\n<p>In order to continue, you need one thing. you have to implement the <code>IConnectionStringProvider</code> in order to user the <code>DBContext</code>. create a class for <code>IConnectionStringProvider</code> and pass an instance to the <code>DBContext</code> when ever needed.</p>\n<pre><code class=\"hljs cs language-cs\"><span class=\"hljs-keyword\">using</span> BestAppEver.DAL.Infrastructure.Interfaces;\n\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">BestAppEver.DAL</span>\n{\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConnectionProvider</span> : <span class=\"hljs-title\">IConnectionStringProvider</span>\n  {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">string</span> <span class=\"hljs-title\">GetConnectionString</span>()</span>\n    {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Server=localhost;Database=bestappdata;UID=root;Password=password&quot;</span>; <span class=\"hljs-comment\">// Should be taken from a configuration file </span>\n    }\n  }\n}\n</code></pre>\n<p>You should initialize <code>DBContext</code> only once .you should keep this instance in a global scope. for this demonstration i use .Net core DI to setup my dependencies.</p>\n<pre><code class=\"hljs cs language-cs\"><span class=\"hljs-keyword\">using</span> BestAppEver.Injection;\n<span class=\"hljs-keyword\">using</span> BestAppEver.DAL.Infrastructure.Interfaces;\n<span class=\"hljs-keyword\">using</span> BestAppEver.DAL.Infrastructure;\n\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">BestAppEver.DAL.Modules</span>\n{\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DataAccessModule</span> : <span class=\"hljs-title\">IModule</span>\n  {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Bootstrap</span>(<span class=\"hljs-params\">IDependencyStore store</span>)</span>\n    {\n      store.Singleton&lt;IConnectionStringProvider, ConnectionProvider&gt;();\n      store.Singleton&lt;IDBContext, DBContext&gt;();\n    }\n  }\n}\n</code></pre>\n<p>I use providers to wrap my database code.</p>\n<pre><code class=\"hljs cs language-cs\"><span class=\"hljs-keyword\">using</span> System;\n<span class=\"hljs-keyword\">using</span> System.Collections.Generic;\n<span class=\"hljs-keyword\">using</span> System.Threading.Tasks;\n<span class=\"hljs-keyword\">using</span> BestAppEver.DAL.Infrastructure.Interfaces;\n<span class=\"hljs-keyword\">using</span> BestAppEver.DAL.Infrastructure.Models.Concrete;\n<span class=\"hljs-keyword\">using</span> BestAppEver.Models.Data;\n<span class=\"hljs-keyword\">using</span> BestAppEver.Providers.Data;\n\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">BestAppEver.DAL.Providers</span>\n{\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserProvider</span> : <span class=\"hljs-title\">IUserProvider</span>\n  {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">readonly</span> IDBContext _context;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">UserProvider</span>(<span class=\"hljs-params\">IDBContext context</span>)</span>\n    {\n      _context = context;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">async</span> Task <span class=\"hljs-title\">Add</span>(<span class=\"hljs-params\">IUser user</span>)</span>\n    {\n      <span class=\"hljs-keyword\">var</span> unit = _context.Unit();\n      unit.UserRepository.Add(user);\n      <span class=\"hljs-keyword\">await</span> unit.CommitAsync();\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">async</span> Task&lt;IUser&gt; <span class=\"hljs-title\">Get</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span> id</span>)</span>\n    {\n      <span class=\"hljs-keyword\">var</span> unit = _context.Unit();\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> unit.UserRepository.GetByKeyAsync(id);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">async</span> IEnumerable&lt;IUser&gt; <span class=\"hljs-title\">GetAll</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span> skip, <span class=\"hljs-built_in\">int</span> take, <span class=\"hljs-built_in\">string</span> serchText</span>)</span>\n    {\n      <span class=\"hljs-keyword\">var</span> getter = _context.Unit().UserRepository.Get();\n      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">string</span>.IsNullOrWhiteSpace(serchText))\n      {\n        getter.Where.FirstName.Contains(serchText)\n          .Or.LastName.Contains(serchText);\n      }\n\n      getter.Skip(skip).Take(take);\n\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> getter.QueryAsync();\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">async</span> Task&lt;IUser&gt; <span class=\"hljs-title\">GetAsync</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span> id</span>)</span>\n    {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> _context.Unit().UserRepository.GetByKeyAsync(id);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">async</span> Task&lt;IUser&gt; <span class=\"hljs-title\">getByEmail</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> email</span>)</span>\n    {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> _context.Unit().UserRepository.Get()\n        .Where.Email.EqualsTo(email).Filter().FirstOrDefaultAsync();\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">async</span> Task <span class=\"hljs-title\">Update</span>(<span class=\"hljs-params\">IUser user</span>)</span>\n    {\n      <span class=\"hljs-keyword\">await</span> (user  <span class=\"hljs-keyword\">as</span> User).DatabaseUnitOfWork.CommitAsync();\n    }\n  }\n}\n</code></pre>\n<p>This could have problems with some databases as this is in development and has only tested in Windows 10, Mac OSX Sierra, Ubuntu 16.04. You can contribute to the code through <strong>GitHub</strong></p>"},"page":"Post","topTags":["programming","aws","web","machineLearning","react","javascript","dataScience","typescript","r","csharp"],"relatedPosts":[{"title":"One Method, Different Implementations","tags":["programming","csharp"],"fullUrl":"https://rusith.me/blog/one-method-different-implementations","date":"Sat, Aug 4, 2018","description":"We can set Func<>s as properties, so people can call them just like methods, and we can change the function from the constructor according to the user's needs. in this example, I am creating a class which has few methods to download data, the user of the class can decide whether they should cache the results or not","banner":null},{"title":"Deploying an app on AWS ECS with CDK","tags":["programming","nextJS","react","aws","ecs","typescript","cdk","devops"],"fullUrl":"https://rusith.me/blog/deploy-app-on-aws-ecs-with-cdk-auto-scaling-and-load-balancing","date":"Wed, Feb 15, 2023","description":"How to deploy an application on AWS ECS with load-balancing and auto-scaling using CDK by writing the CDK code in TypeScript","banner":"/post-data/2023-02-15-deploying-react-app-on-ecs/banner.png"},{"title":"Testing Redux Connected React Components Using Jest","tags":["programming","javascript","react","redux","testing","jest"],"fullUrl":"https://rusith.me/blog/testing-react-redux-connected-components-using-jest","date":"Mon, Apr 27, 2020","description":"Testing React components connected to a Redux store using Jest and React Testing Library.","banner":"/post-data/2020-04-27-testing-redux-connect/banner.png"}]},"__N_SSG":true}