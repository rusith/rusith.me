{"pageProps":{"post":{"fileName":"2019-07-25-re-usable-presto-worker-image.md","fullPath":"/home/runner/work/rusith.me/rusith.me/modules/blog/posts/2019-07-25-re-usable-presto-worker-image.md","title":"Creating a Re-Usable Presto Worker Image in EC2","tags":["programming","bigdata","aws","cloud"],"comments":true,"description":"Creating a machine image that can be used to spin up presto worker instances without configuring each one. this could be helpful when you don't want to use any  orchestration tool","dateCreated":"Thu Jul 25 2019 00:00:00 GMT+0000 (Coordinated Universal Time)","dateModified":"Thu Jul 25 2019 00:00:00 GMT+0000 (Coordinated Universal Time)","datePublished":"Thu Jul 25 2019 00:00:00 GMT+0000 (Coordinated Universal Time)","dependencies":"AWS","about":"Demonstrates how to create a re-usable Presto worker image using a AWS EC2 instance","banner":"/post-data/2019-07-25-re-usable-presto-worker/5-workers-dashboard.png","path":"/blog/re-usable-presto-worker-image-ec2","oldPath":"/2019/07/25/re-usable-presto-worker-image","dateCreatedFormatted":"Thu, Jul 25, 2019","fullUrl":"https://rusith.me/blog/re-usable-presto-worker-image-ec2","fileContent":"---\ntitle: Creating a Re-Usable Presto Worker Image in EC2\ntags: programming bigdata aws cloud\ncomments: true\ndescription: Creating a machine image that can be used to spin up presto worker instances without configuring each one. this could be helpful when you don't want to use any  orchestration tool\ndateCreated: 2019-07-25\ndateModified: 2019-07-25\ndatePublished: 2019-07-25\ndependencies: AWS\nabout: Demonstrates how to create a re-usable Presto worker image using a AWS EC2 instance\nbanner: /post-data/2019-07-25-re-usable-presto-worker/5-workers-dashboard.png\npath: /re-usable-presto-worker-image-ec2\noldPath: /2019/07/25/re-usable-presto-worker-image\n---\n\nWhen you have to create a Presto cluster, managing a lot of workers is a pain. So people have built different tools around it to make this easy. but when you don't have any tool like that for the rescue, you can use this approach to set up a machine image that can be used to run as many workers as you want without doing any configuration on each machine.\n\nOkay, first you need to get this right on one instance.\n\nBefore you begin, make sure\n\n- That you have a working coordinator instance.\n- You have a security group for your coordinator node\n\nOkay, Assuming you have a working coordinator node, let's start creating our Presto worker image.\n\nCreate a security group for the worker nodes and allow traffic from the coordinator and allow traffic from the same security group. Also, edit the coordinator group to allow traffic from the worker group.\n\n<img alt=\"Coordinator config\" src=\"$$base_url/post-data/2019-07-25-re-usable-presto-worker/sg-coordinator.png\">\n\n<img alt=\"Worker config\" src=\"$$base_url/post-data/2019-07-25-re-usable-presto-worker/sg-worker.png\">\n\nOkay, Now our security rules are ready. lets install Presto.\nSpin up a node and connect to it.\n\nNow we can download and install Presto. (copy the latest version link from the Presto website)\n\n```sh\ncd ~\nwget https://repo1.maven.org/maven2/io/prestosql/presto-server/316/presto-server-316.tar.gz -O ./presto.tar.gz\ntar -xvzf presto.tar.gz # extract the archive\nmv ./presto-server-316 ./presto #move to the ~/presto folder\nrm ./presto.tar.gz\n```\n\nOkay, Now we should install the required tools which are Java and Python.\n\n```sh\n# Installing Java\nsudo apt-get update\nsudo apt-get install openjdk-8-jdk\n\n# Install Python\nsudo apt install python2.7 python-pip\n```\n\nLet's also create the missing `data` folder for Presto.\n\n```sh\nmkdir ~/presto/data\n```\n\nWith that done, we can now configure Presto installation.\n\nCreate a the file `~/presto/etc/node.properties`.\n\n```conf\nnode.environment=production\nnode.id=ffffffff-ffff-ffff-ffff-ffffffffffff\nnode.data-dir=~/presto/data\n```\n\nCreate the file `~/presto/etc/jvm.config`.\n\n```\n-server\n-Xmx16G\n-XX:+UseG1GC\n-XX:G1HeapRegionSize=32M\n-XX:+UseGCOverheadLimit\n-XX:+ExplicitGCInvokesConcurrent\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:+ExitOnOutOfMemoryError\n```\n\nCreate the file `~/presto/etc/config.properties` (replace the coordinator ip)\n\n```conf\ncoordinator=false\nhttp-server.http.port=8081\ndiscovery.uri=http://<coordinator ip>:8081\n```\n\nYou can also configure catalogs at this time.\n\nNow give it a try by running Presto.\n\n```sh\ncd ~/presto/bin\n./launcher run\n```\n\nIf you get the service started message. you are ready to go ahead. you can stop Presto service now.\n\nHere comes the interesting part. in the `node.properties` file, we have the value `ffffffff-ffff-ffff-ffff-ffffffffffff`. actually, this value should be a GUID.\n\nSo what we are going to do is to auto-generate a GUID and replace this value when the system is starting. and run Presto as a service.\n\nLet's create a script that will run at startup and start Presto service.\n\ncreate the file `~/runpresto.sh` and put the content\n\n```sh\n#!/bin/sh -\n# Replace the placeholder with a GUID\nsed -i \"s/ffffffff-ffff-ffff-ffff-ffffffffffff/$(uuidgen)/\" /home/ubuntu/presto/etc/node.properties\n# Run presto\n/home/ubuntu/presto/bin/launcher run\n```\n\nAnd make the file runnable.\n\n```sh\nchmod u+x ~/runpresto.sh\n```\n\nNow we can run this script at startup. for that, we can use `systemd`.\nLet's create a service file for Presto.\n\nCreate the file `/etc/systemd/system/presto.service`.\n\n```conf\nDescription=Presto Worker\n\n[Service]\nExecStart=/home/ubuntu/runpresto.sh\nRemainAfterExit=no\nRestart=on-failure\nRestartSec=5s\n\n[Install]\nWantedBy=multi-user.targer\n```\n\nHere we say the service should re-start in 5 seconds if failed.\nNow we can register our service.\n\nrun `sudo systemctl daemon-reload` and\n`sudo systemctl enable presto.service` to make the script run at startup.\n\nRestart the instance and Wait few seconds and run `sudo systemctl status presto.service` to see if the service is running.\n\n<img alt=\"Presto Service Running\" src=\"$$base_url/post-data/2019-07-25-re-usable-presto-worker/presto-running.png\">\n\nyou can also check the Presto dashboard to see if the worker is connected.\n\n<img alt=\"Presto Service Running\" src=\"$$base_url/post-data/2019-07-25-re-usable-presto-worker/one-worker.png\">\n\nNow, stop the instance and create a machine image from it.\n\n<img alt=\"Presto Service Running\" src=\"$$base_url/post-data/2019-07-25-re-usable-presto-worker/worker-image.png\">\n\nNow you can use this machine image to run as many workers you want.\n\nHere, I have started 5 workers.\n\n<img alt=\"Presto Service Running\" src=\"$$base_url/post-data/2019-07-25-re-usable-presto-worker/5-workers-console.png\">\n\nAnd all workers are connected and ready to use.\n\n<img alt=\"Presto Service Running\" src=\"$$base_url/post-data/2019-07-25-re-usable-presto-worker/5-workers-dashboard.png\">\n","parsedContent":"<p>When you have to create a Presto cluster, managing a lot of workers is a pain. So people have built different tools around it to make this easy. but when you don't have any tool like that for the rescue, you can use this approach to set up a machine image that can be used to run as many workers as you want without doing any configuration on each machine.</p>\n<p>Okay, first you need to get this right on one instance.</p>\n<p>Before you begin, make sure</p>\n<ul>\n<li>That you have a working coordinator instance.</li>\n<li>You have a security group for your coordinator node</li>\n</ul>\n<p>Okay, Assuming you have a working coordinator node, let's start creating our Presto worker image.</p>\n<p>Create a security group for the worker nodes and allow traffic from the coordinator and allow traffic from the same security group. Also, edit the coordinator group to allow traffic from the worker group.</p>\n<p><img alt=\"Coordinator config\" src=\"https://rusith.me/post-data/2019-07-25-re-usable-presto-worker/sg-coordinator.png\"></p>\n<p><img alt=\"Worker config\" src=\"https://rusith.me/post-data/2019-07-25-re-usable-presto-worker/sg-worker.png\"></p>\n<p>Okay, Now our security rules are ready. lets install Presto.\nSpin up a node and connect to it.</p>\n<p>Now we can download and install Presto. (copy the latest version link from the Presto website)</p>\n<pre><code class=\"hljs sh language-sh\"><span class=\"hljs-built_in\">cd</span> ~\nwget https://repo1.maven.org/maven2/io/prestosql/presto-server/316/presto-server-316.tar.gz -O ./presto.tar.gz\ntar -xvzf presto.tar.gz <span class=\"hljs-comment\"># extract the archive</span>\n<span class=\"hljs-built_in\">mv</span> ./presto-server-316 ./presto <span class=\"hljs-comment\">#move to the ~/presto folder</span>\n<span class=\"hljs-built_in\">rm</span> ./presto.tar.gz\n</code></pre>\n<p>Okay, Now we should install the required tools which are Java and Python.</p>\n<pre><code class=\"hljs sh language-sh\"><span class=\"hljs-comment\"># Installing Java</span>\nsudo apt-get update\nsudo apt-get install openjdk-8-jdk\n\n<span class=\"hljs-comment\"># Install Python</span>\nsudo apt install python2.7 python-pip\n</code></pre>\n<p>Let's also create the missing <code>data</code> folder for Presto.</p>\n<pre><code class=\"hljs sh language-sh\"><span class=\"hljs-built_in\">mkdir</span> ~/presto/data\n</code></pre>\n<p>With that done, we can now configure Presto installation.</p>\n<p>Create a the file <code>~/presto/etc/node.properties</code>.</p>\n<pre><code class=\"hljs conf language-conf\"><span class=\"hljs-attr\">node.environment</span>=production\n<span class=\"hljs-attr\">node.id</span>=ffffffff-ffff-ffff-ffff-ffffffffffff\n<span class=\"hljs-attr\">node.data-dir</span>=~/presto/data\n</code></pre>\n<p>Create the file <code>~/presto/etc/jvm.config</code>.</p>\n<pre><code>-server\n-Xmx16G\n-XX:+UseG1GC\n-XX:G1HeapRegionSize=32M\n-XX:+UseGCOverheadLimit\n-XX:+ExplicitGCInvokesConcurrent\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:+ExitOnOutOfMemoryError\n</code></pre>\n<p>Create the file <code>~/presto/etc/config.properties</code> (replace the coordinator ip)</p>\n<pre><code class=\"hljs conf language-conf\"><span class=\"hljs-attr\">coordinator</span>=<span class=\"hljs-literal\">false</span>\n<span class=\"hljs-attr\">http-server.http.port</span>=<span class=\"hljs-number\">8081</span>\n<span class=\"hljs-attr\">discovery.uri</span>=http://&lt;coordinator ip&gt;:<span class=\"hljs-number\">8081</span>\n</code></pre>\n<p>You can also configure catalogs at this time.</p>\n<p>Now give it a try by running Presto.</p>\n<pre><code class=\"hljs sh language-sh\"><span class=\"hljs-built_in\">cd</span> ~/presto/bin\n./launcher run\n</code></pre>\n<p>If you get the service started message. you are ready to go ahead. you can stop Presto service now.</p>\n<p>Here comes the interesting part. in the <code>node.properties</code> file, we have the value <code>ffffffff-ffff-ffff-ffff-ffffffffffff</code>. actually, this value should be a GUID.</p>\n<p>So what we are going to do is to auto-generate a GUID and replace this value when the system is starting. and run Presto as a service.</p>\n<p>Let's create a script that will run at startup and start Presto service.</p>\n<p>create the file <code>~/runpresto.sh</code> and put the content</p>\n<pre><code class=\"hljs sh language-sh\"><span class=\"hljs-meta\">#!/bin/sh -</span>\n<span class=\"hljs-comment\"># Replace the placeholder with a GUID</span>\nsed -i <span class=\"hljs-string\">&quot;s/ffffffff-ffff-ffff-ffff-ffffffffffff/<span class=\"hljs-subst\">$(uuidgen)</span>/&quot;</span> /home/ubuntu/presto/etc/node.properties\n<span class=\"hljs-comment\"># Run presto</span>\n/home/ubuntu/presto/bin/launcher run\n</code></pre>\n<p>And make the file runnable.</p>\n<pre><code class=\"hljs sh language-sh\"><span class=\"hljs-built_in\">chmod</span> u+x ~/runpresto.sh\n</code></pre>\n<p>Now we can run this script at startup. for that, we can use <code>systemd</code>.\nLet's create a service file for Presto.</p>\n<p>Create the file <code>/etc/systemd/system/presto.service</code>.</p>\n<pre><code class=\"hljs conf language-conf\"><span class=\"hljs-attr\">Description</span>=Presto Worker\n\n<span class=\"hljs-section\">[Service]</span>\n<span class=\"hljs-attr\">ExecStart</span>=/home/ubuntu/runpresto.sh\n<span class=\"hljs-attr\">RemainAfterExit</span>=<span class=\"hljs-literal\">no</span>\n<span class=\"hljs-attr\">Restart</span>=<span class=\"hljs-literal\">on</span>-failure\n<span class=\"hljs-attr\">RestartSec</span>=<span class=\"hljs-number\">5</span>s\n\n<span class=\"hljs-section\">[Install]</span>\n<span class=\"hljs-attr\">WantedBy</span>=multi-user.targer\n</code></pre>\n<p>Here we say the service should re-start in 5 seconds if failed.\nNow we can register our service.</p>\n<p>run <code>sudo systemctl daemon-reload</code> and\n<code>sudo systemctl enable presto.service</code> to make the script run at startup.</p>\n<p>Restart the instance and Wait few seconds and run <code>sudo systemctl status presto.service</code> to see if the service is running.</p>\n<p><img alt=\"Presto Service Running\" src=\"https://rusith.me/post-data/2019-07-25-re-usable-presto-worker/presto-running.png\"></p>\n<p>you can also check the Presto dashboard to see if the worker is connected.</p>\n<p><img alt=\"Presto Service Running\" src=\"https://rusith.me/post-data/2019-07-25-re-usable-presto-worker/one-worker.png\"></p>\n<p>Now, stop the instance and create a machine image from it.</p>\n<p><img alt=\"Presto Service Running\" src=\"https://rusith.me/post-data/2019-07-25-re-usable-presto-worker/worker-image.png\"></p>\n<p>Now you can use this machine image to run as many workers you want.</p>\n<p>Here, I have started 5 workers.</p>\n<p><img alt=\"Presto Service Running\" src=\"https://rusith.me/post-data/2019-07-25-re-usable-presto-worker/5-workers-console.png\"></p>\n<p>And all workers are connected and ready to use.</p>\n<p><img alt=\"Presto Service Running\" src=\"https://rusith.me/post-data/2019-07-25-re-usable-presto-worker/5-workers-dashboard.png\"></p>"},"page":"Post","topTags":["programming","aws","web","machineLearning","react","javascript","dataScience","typescript","r","csharp"],"relatedPosts":[{"title":"Deploying an app on AWS ECS with CDK","tags":["programming","nextJS","react","aws","ecs","typescript","cdk","devops"],"fullUrl":"https://rusith.me/blog/deploy-app-on-aws-ecs-with-cdk-auto-scaling-and-load-balancing","date":"Wed, Feb 15, 2023","description":"How to deploy an application on AWS ECS with load-balancing and auto-scaling using CDK by writing the CDK code in TypeScript","banner":"/post-data/2023-02-15-deploying-react-app-on-ecs/banner.png"},{"title":"Running a Nuget Feed on S3 with Automated Deployments","tags":["programming","dotnet","s3","aws","nuget"],"fullUrl":"https://rusith.me/blog/nuget-feed-on-s3","date":"Sat, Nov 2, 2019","description":"There are many ways of creating a Nuget feed. but did you know that you can run a Nuget feed on S3 without any computing infrastructure? In this post, I will show you how you can create a Nuget feed on S3 using Sleet and automate the deployment process for packages.","banner":"/post-data/2019-11-03-nuget-feed-s3/banner.png"},{"title":"Deploying a Website on S3 With SSL, Continuous Integration","tags":["aws","programming","web"],"fullUrl":"https://rusith.me/blog/building-a-website-on-s3","date":"Mon, Aug 5, 2019","description":"In this post, I am creating a website and host it on S3 and setup a continuous integration pipeline setup using Gitlab","banner":"/post-data/2019-08-14-building-a-website-on-s3/banner.png"}]},"__N_SSG":true}