{"pageProps":{"post":{"fileName":"2023-02-15-deploying-react-app-on-ecs.md","fullPath":"/home/runner/work/rusith.me/rusith.me/modules/blog/posts/2023-02-15-deploying-react-app-on-ecs.md","layout":"post","title":"Deploying an app on AWS ECS with CDK","tags":["programming","nextJS","react","aws","ecs","typescript","cdk","devops"],"comments":true,"description":"How to deploy an application on AWS ECS with load-balancing and auto-scaling using CDK by writing the CDK code in TypeScript","dateCreated":"Wed Feb 15 2023 00:00:00 GMT+0000 (Coordinated Universal Time)","dateModified":"Wed Feb 15 2023 00:00:00 GMT+0000 (Coordinated Universal Time)","datePublished":"Wed Feb 15 2023 00:00:00 GMT+0000 (Coordinated Universal Time)","about":"How to deploy an application on AWS ECS with load-balancing and auto-scaling using CDK by writing the CDK code in TypeScript","banner":"/post-data/2023-02-15-deploying-react-app-on-ecs/banner.png","path":"/blog/deploy-app-on-aws-ecs-with-cdk-auto-scaling-and-load-balancing","dateCreatedFormatted":"Wed, Feb 15, 2023","fullUrl":"https://rusith.me/blog/deploy-app-on-aws-ecs-with-cdk-auto-scaling-and-load-balancing","oldPath":null,"fileContent":"---\nlayout: post\ntitle: Deploying an app on AWS ECS with CDK\ntags: programming nextJS react aws ecs typescript cdk devops\ncomments: true\ndescription: How to deploy an application on AWS ECS with load-balancing and auto-scaling using CDK by writing the CDK code in TypeScript\ndateCreated: 2023-02-15\ndateModified: 2023-02-15\ndatePublished: 2023-02-15\nabout: How to deploy an application on AWS ECS with load-balancing and auto-scaling using CDK by writing the CDK code in TypeScript\nbanner: /post-data/2023-02-15-deploying-react-app-on-ecs/banner.png\npath: /deploy-app-on-aws-ecs-with-cdk-auto-scaling-and-load-balancing\n---\n\n<img alt=\"Page banner\" class=\"$$styles.banner\" src=\"$$page_banner_full_path\">\n\nIn this article, I am trying to demonstrate the steps to get an application running on AWS ECS with load-balancing and auto-scaling enabled using CDK. We will be writing the CDK code using TypeScript\n\nI am choosing NextJS to build this application, mainly because NextJS is a full-stack framework and it makes sense to enable auto-scaling on such an application. but this could be any app/API. which has an endpoint that returns some HTML.\n\n### Root folder Structure\n\nLet's first define the basic folder structure of this project, We will have the folder `app`\nwhich will contain our application code and the `infra` folder will contain the infrastructure definition\nthat we are going to write using CDK.\n\n### Creating the application\n\nAs I previously mentioned, I am going to use NextJS to write my application\nAnd I will not do any changes to the NextJS boilerplate code\nas it is not important what the application does at this moment.\n\nLet's first initialize a new NextJS app inside the `app` directory by running the below command inside the `app` directory.\n\n```sh\ncd app && npx create-next-app@latest --typescript .\n```\n\nWhich will result in a folder structure like this:\n\n<img src=\"$$base_url/post-data/2023-02-15-deploying-react-app-on-ecs/folder-structure-1.png\" />\n\n### Containerize the application\n\nNow we have our application, we have to dockerize it in order to deploy it using CDK.\nWe can dockerize a NextJS application by creating a `Dockerfile` inside the `app` folder\n\nThis is a simple `Dockerfile` that we can use to dockerize our application, but you can change it based on your requirements.\n\n```Dockerfile\nFROM node:18-alpine\nEXPOSE 3000\n\nRUN mkdir /app\nWORKDIR /app\n\nCOPY . /app\n\nRUN yarn install\nENV NODE_ENV=production\n\nRUN yarn build\nCMD [\"yarn\", \"start\"]\n\n```\n\nNow we are ready from the app side.\n\n### Initializing the CDK application\n\nTo initialize the CDK application, we have to run the below command inside the `infra`\ndirectory. This will generate the code necessary to get started with defining\nthe infrastructure of the project.\n\n```sh\ncdk init app --language typescript .\n```\n\nThe new folder structure inside `infra` folder will look like this\n\n<img src=\"$$base_url/post-data/2023-02-15-deploying-react-app-on-ecs/folder-structure-2.png\" />\n\nNow, let's change the content of the `bin/infra.ts` file to the code below,\nThis is the entry point of the CDK application. We are initializing the `InfraStack` which\nwe import from `lib` folder.\n\n```ts\n#!/usr/bin/env node\nimport \"source-map-support/register\"\nimport * as cdk from \"aws-cdk-lib\"\nimport { InfraStack } from \"../lib/infra-stack\"\n\nconst app = new cdk.App()\nnew InfraStack(app, \"InfraStack\")\n```\n\n### Defining the infrastructure\n\nNow we are ready to define the infrastructure of the project. To make it easier, I will only have one file\nwhich is `lib/infra-stack.ts` and I will define all the resources in this file. But it is a good practice to\nbreak the infrastructure into multiple files and import them in the `infra-stack.ts` file.\n\nAs the initial step, let's change `lib/infra-stack.ts` file,\n\n```ts\nimport { Stack, StackProps } from \"aws-cdk-lib\"\nimport { Construct } from \"constructs\"\n\nexport class InfraStack extends Stack {\n  constructor(scope: Construct, id: string, props?: StackProps) {\n    super(scope, id, {\n      env: {\n        account: process.env.AWS_ACCOUNT_ID,\n        region: process.env.AWS_DEFAULT_REGION\n      }\n    })\n  }\n}\n```\n\nHere we are initializing the stack and setting the `account` and `region` from the environment variables.\nHaving the `account` and `region` is required to deploy the stack.\n\n#### Defining the VPC\n\nLet's start by creating a VPC for our application. All other resources will be created inside this VPC.\n\n```ts\nconst vpc = new Vpc(this, \"AppVPC\", {\n  natGateways: 0\n})\n```\n\n#### Defining the ECS cluster\n\nNow we have to define an ECS cluster that contains all resources related to our ECS.\n\n```ts\nconst cluster = new Cluster(this, \"Cluster\", { vpc })\n```\n\n#### Defining app task\n\nBefore defining the task, we have to define a role for the task.\nThis role has to be based on the `ecs-tasks.amazonaws.com` role.\n\n```ts\nconst taskRole = new Role(this, \"AppRole\", {\n  assumedBy: new ServicePrincipal(\"ecs-tasks.amazonaws.com\")\n})\n```\n\nNow we have to add required permissions to the role,\nThese permissions could change based on the requirements of the project.\nFor this project, we are going to add permissions for `log` and `CloudWatch`.\n\n```ts\ntaskRole.addToPolicy(\n  new PolicyStatement({\n    resources: [\"*\"],\n    actions: [\"logs:*\", \"cloudwatch:*\"]\n  })\n)\n```\n\nNow we are ready to define the task. The task is the basic unit that runs on the actual container. As we are targeting EC2, we have to define the `compatibility` as `EC2`. And `obtainExecutionRole` will create the execution role for this task if it does not exist.\n\n```ts\nconst taskDefinition = new TaskDefinition(this, \"AppTask\", {\n  taskRole,\n  compatibility: Compatibility.EC2\n})\ntaskDefinition.obtainExecutionRole()\n```\n\n#### Defining the auto-scaling group\n\nNow we have to define an auto-scaling group that will handle the\ncreation and destruction of the EC2 instances. based on the\nrequirements of the capacity provider which will be defined later.\nHere I am using a `t3.nano` instance type, this can be changed based on the requirements. And I am setting the `desiredCapacity` to `0` so that no instances will be created at the beginning.\n\n```ts\nconst asg = new AutoScalingGroup(this, \"ASG\", {\n  instanceType: new InstanceType(\"t3.nano\"),\n  machineImage: EcsOptimizedImage.amazonLinux2(),\n  associatePublicIpAddress: true,\n  maxCapacity: 3,\n  desiredCapacity: 0,\n  minCapacity: 0,\n  vpc: vpc,\n  vpcSubnets: { subnetType: SubnetType.PUBLIC },\n  newInstancesProtectedFromScaleIn: false\n})\n```\n\n#### Defining the capacity provider\n\nWe are going to use the capacity provider to connect the auto-scaling group and the ECS cluster. This will handle all the scaling scenarios. I am setting the `enableManagedScaling` to `true` so that the capacity provider will handle the scaling of the instances. And I am setting the `targetCapacityPercent` to `100` so that the capacity provider will always try to keep the instances at 100% capacity and will not create additional instances. It's also important to note, by setting the `enableManagedTerminationProtection` to `false` we are allowing the capacity provider to terminate the instances if it is required.\n\n```ts\nconst capacityProvider = new AsgCapacityProvider(this, \"EC2CapacityProvider\", {\n  autoScalingGroup: asg,\n  enableManagedScaling: true,\n  enableManagedTerminationProtection: false,\n  targetCapacityPercent: 100\n})\n\ncluster.addAsgCapacityProvider(capacityProvider)\n```\n\n#### Defining the app service\n\nNow we are ready to define the service which will contain the task. I am setting the `minHealthyPercent` to `0` so that the service will not wait for the instances to be healthy before starting the deployment. And I am setting the `capacityProviderStrategies` to use the capacity provider which we defined earlier.\n\n```ts\nconst service = new Ec2Service(this, \"AppService\", {\n  taskDefinition,\n  cluster,\n  desiredCount: 1,\n  minHealthyPercent: 0,\n  capacityProviderStrategies: [\n    {\n      capacityProvider: capacityProvider.capacityProviderName,\n      weight: 1,\n      base: 0\n    }\n  ]\n})\n```\n\n#### Defining the container\n\nNow we are ready to define the container where the task will be running, Here I am\nusing `ContainerImage.fromAsset` to build the image from the local directory. CDK will\nbuild the image locally and push it to ECR. I am also using `awsLogs` driver to push the logs to CloudWatch. And I am setting the `memoryReservationMiB` to `200` so that the container will have a minimum of 200MB of memory. This amount can be changed based on the\nrequirements of the application. This value will be taken into consideration when scaling the app. And I am also mapping port `3000` of the container to port `3000` of the host. As NextJS is by default running on port `3000`.\n\n```ts\nconst container = taskDefinition.addContainer(\"AppContainer\", {\n  linuxParameters: new LinuxParameters(this, \"AppLinuxParams\"),\n  image: ContainerImage.fromAsset(\"../app\"),\n  logging: LogDriver.awsLogs({\n    streamPrefix: \"app\",\n    logRetention: RetentionDays.ONE_WEEK\n  }),\n  environment: {\n    NODE_ENV: \"production\"\n  },\n  memoryReservationMiB: 200\n})\n\ncontainer.addPortMappings({\n  containerPort: 3000,\n  hostPort: 3000,\n  protocol: ECSProtocol.TCP\n})\n```\n\n### HTTP certificate\n\nNow we have to have a certificate for the domain which we are going to use. This certificate will be used by the load balancer to serve the traffic over HTTPS. Make sure you create this certificate in the `us-east-1` region. This is a requirement for the load balancer.\n\nAs we are not in the `us-east-1` region, we have to import the certificate using the `Certificate.fromCertificateArn` method. You can copy the ARN of the certificate from the AWS console. I am setting the `APP_CERTIFICATE_ARN` environment variable to the ARN of the certificate.\n\n```ts\nconst domainCertificate = Certificate.fromCertificateArn(this, \"AppCertificate\", process.env.APP_CERTIFICATE_ARN!)\n```\n\n### Defining the load balancer\n\nNow we are ready to define the load balancer,\n\n```ts\nconst loadBalancer = new ApplicationLoadBalancer(this, \"AppLoadBalancer\", {\n  vpc,\n  internetFacing: true,\n  vpcSubnets: { subnetType: SubnetType.PUBLIC }\n})\n```\n\n##### Redirecting HTTP to HTTPS\n\nWe will redirect the HTTP traffic to HTTPS. This is done by adding a redirect rule to the load balancer. This will redirect all the traffic coming from port `80` to port `443` over HTTPS.\n\n```ts\nloadBalancer.addRedirect({\n  sourcePort: 80,\n  sourceProtocol: ApplicationProtocol.HTTP,\n  targetPort: 443,\n  targetProtocol: ApplicationProtocol.HTTPS\n})\n```\n\n##### Allow egress traffic\n\nWe have to allow the load balancer to make requests to the internet. This is done by adding a security group rule to the load balancer.\n\n```ts\nloadBalancer.connections.allowToAnyIpv4(Port.allTcp(), \"All Out\")\n```\n\n##### Connecting the load balancer to the app\n\nNow we are ready to connect the load balancer to the app.\nFirst, we will create a listener on port 443 and add the certificate which we created earlier.\nThen we can add the app service as a target to the listener.\n\nAns we also have to make sure the load balancer can be accessed from the internet. This can be done\nusing `allowFromAnyIpv4` method for ports `80` and `443`.\n\nFinally, we will allow the load balancer to make requests to the app on port `3000`.\n\n```ts\nconst listener = loadBalancer.addListener(\"AutomateListener\", {\n  port: 443,\n  certificates: [domainCertificate],\n  protocol: ApplicationProtocol.HTTPS\n})\n\nlistener.addTargets(\"AppTarget\", {\n  healthCheck: {\n    enabled: true,\n    protocol: Protocol.HTTP\n  },\n  port: 3000,\n  deregistrationDelay: Duration.seconds(3) as any,\n  protocol: ApplicationProtocol.HTTP,\n  targets: [service]\n})\n\nloadBalancer.connections.allowFromAnyIpv4(Port.tcp(80), \"Ingress HTTP internet\")\nloadBalancer.connections.allowFromAnyIpv4(Port.tcp(443), \"Ingress HTTPS internet\")\n\nfor (const subnet of vpc.publicSubnets as any) {\n  asg.connections.allowFrom(Peer.ipv4(subnet.ipv4CidrBlock), Port.tcp(3000), \"Ingress from ALB to App\")\n}\n```\n\n### Hosted zone and subdomain\n\nAs my domain is handled by AWS, I will add the subdomain to the hosted zone also here, If this is not the case for you, you can skip this step and directly point the domain to the load balancer's public IP which you can find after the deployment is done in the AWS console.\n\n```ts\nconst hostedZone = PublicHostedZone.fromLookup(this, \"HostedZone\", {\n  domainName: \"<some-domain>.com\"\n})\n\nnew ARecord(this, \"AppARecord\", {\n  zone: hostedZone,\n  target: RecordTarget.fromAlias(new LoadBalancerTarget(loadBalancer as any)),\n  recordName: \"app\"\n})\n```\n\n### Deploying the app,\n\nNow our infrastructure definition is ready to go.\nBefore deploying, we have to bootstrap the application, Before that, we have to make sure we have\nthe AWS credentials are set in the environment variables. And also make sure the `AWS_ACCOUNT_ID`\nand `APP_CERTIFICATE_ARN` environment variables are set.\n\n```sh\n# For bash:\nexport AWS_ACCOUNT_ID=\"<AWS_ACCOUNT_ID>\"\nexport AWS_ACCESS_KEY_ID=\"<AWS_ACCESS_KEY_ID>\"\nexport AWS_SECRET_ACCESS_KEY=\"<AWS_SECRET_ACCESS_KEY>\"\nexport AWS_DEFAULT_REGION=\"<REGION>\"\nexport APP_CERTIFICATE_ARN=\"arn:aws:acm:...\"\n```\n\nNow we can run the below command inside the `infra` folder to bootstrap the app,\n\n```sh\nnpx aws-cdk bootstrap\n```\n\n<img src=\"$$base_url/post-data/2023-02-15-deploying-react-app-on-ecs/cdk-bootstrap-result.jpg\" />\n\nAnd finally, we can deploy the app using the below command, This will take some time because it has to build the app image and push that to the ECR registry. I am doing this completely from the local machine but the steps are the same if you are using a CI/CD pipeline.\n\nAlso, make sure Docker is running on your machine as the CDK will use the local Docker daemon to build the image.\n\n```sh\nnpx aws-cdk deploy\n```\n\nOnce the deployment is complete, It should return an output like below,\n\n<img src=\"$$base_url/post-data/2023-02-15-deploying-react-app-on-ecs/cdk-deploy-result.png\" />\n\nNow you should see the stack is created in the Cloudfomration console.\n\n<img src=\"$$base_url/post-data/2023-02-15-deploying-react-app-on-ecs/cloudformation-console.png\" />\n\n### Testing the app\n\nNow we can test the app by visiting the domain which you used.\n\n<img src=\"$$base_url/post-data/2023-02-15-deploying-react-app-on-ecs/app.png\" />\n\nNow, If you increase the number of desired tasks for the service, The auto-scaling group will automatically facilitate the scaling by creating new instances.\n\n### Troubleshooting\n\nIf you get the error `The runtime parameter of python3.6 is no longer supported for creating or updating AWS Lambda functions. We recommend you use the new runtime (python3.9)`,\n\nRemove the `aws-cdk` package from the `package.json` file set the version for the package `aws-cdk-lib` to `^2.61.1`, install packages and run deploy again.\n\n### Source code\n\nYou can find the source code for this blog post [here](https://github.com/rusith/2023-02-15-deploying-react-app-on-ecs)\n","parsedContent":"<p><img alt=\"Page banner\" class=\"Post_banner__soX4H\" src=\"https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/banner.png\"></p>\n<p>In this article, I am trying to demonstrate the steps to get an application running on AWS ECS with load-balancing and auto-scaling enabled using CDK. We will be writing the CDK code using TypeScript</p>\n<p>I am choosing NextJS to build this application, mainly because NextJS is a full-stack framework and it makes sense to enable auto-scaling on such an application. but this could be any app/API. which has an endpoint that returns some HTML.</p>\n<h3 id=\"rootfolderstructure\">Root folder Structure</h3>\n<p>Let's first define the basic folder structure of this project, We will have the folder <code>app</code>\nwhich will contain our application code and the <code>infra</code> folder will contain the infrastructure definition\nthat we are going to write using CDK.</p>\n<h3 id=\"creatingtheapplication\">Creating the application</h3>\n<p>As I previously mentioned, I am going to use NextJS to write my application\nAnd I will not do any changes to the NextJS boilerplate code\nas it is not important what the application does at this moment.</p>\n<p>Let's first initialize a new NextJS app inside the <code>app</code> directory by running the below command inside the <code>app</code> directory.</p>\n<pre><code class=\"hljs sh language-sh\"><span class=\"hljs-built_in\">cd</span> app &amp;&amp; npx create-next-app@latest --typescript .\n</code></pre>\n<p>Which will result in a folder structure like this:</p>\n<p><img src=\"https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/folder-structure-1.png\" /></p>\n<h3 id=\"containerizetheapplication\">Containerize the application</h3>\n<p>Now we have our application, we have to dockerize it in order to deploy it using CDK.\nWe can dockerize a NextJS application by creating a <code>Dockerfile</code> inside the <code>app</code> folder</p>\n<p>This is a simple <code>Dockerfile</code> that we can use to dockerize our application, but you can change it based on your requirements.</p>\n<pre><code class=\"hljs Dockerfile language-Dockerfile\"><span class=\"hljs-keyword\">FROM</span> node:<span class=\"hljs-number\">18</span>-alpine\n<span class=\"hljs-keyword\">EXPOSE</span> <span class=\"hljs-number\">3000</span>\n\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> <span class=\"hljs-built_in\">mkdir</span> /app</span>\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span>\n\n<span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> . /app</span>\n\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> yarn install</span>\n<span class=\"hljs-keyword\">ENV</span> NODE_ENV=production\n\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> yarn build</span>\n<span class=\"hljs-keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"hljs-string\">&quot;yarn&quot;</span>, <span class=\"hljs-string\">&quot;start&quot;</span>]</span>\n</code></pre>\n<p>Now we are ready from the app side.</p>\n<h3 id=\"initializingthecdkapplication\">Initializing the CDK application</h3>\n<p>To initialize the CDK application, we have to run the below command inside the <code>infra</code>\ndirectory. This will generate the code necessary to get started with defining\nthe infrastructure of the project.</p>\n<pre><code class=\"hljs sh language-sh\">cdk init app --language typescript .\n</code></pre>\n<p>The new folder structure inside <code>infra</code> folder will look like this</p>\n<p><img src=\"https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/folder-structure-2.png\" /></p>\n<p>Now, let's change the content of the <code>bin/infra.ts</code> file to the code below,\nThis is the entry point of the CDK application. We are initializing the <code>InfraStack</code> which\nwe import from <code>lib</code> folder.</p>\n<pre><code class=\"hljs ts language-ts\"><span class=\"hljs-meta\">#!/usr/bin/env node</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;source-map-support/register&quot;</span>\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> cdk <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;aws-cdk-lib&quot;</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">InfraStack</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../lib/infra-stack&quot;</span>\n\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> cdk.<span class=\"hljs-title class_\">App</span>()\n<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InfraStack</span>(app, <span class=\"hljs-string\">&quot;InfraStack&quot;</span>)\n</code></pre>\n<h3 id=\"definingtheinfrastructure\">Defining the infrastructure</h3>\n<p>Now we are ready to define the infrastructure of the project. To make it easier, I will only have one file\nwhich is <code>lib/infra-stack.ts</code> and I will define all the resources in this file. But it is a good practice to\nbreak the infrastructure into multiple files and import them in the <code>infra-stack.ts</code> file.</p>\n<p>As the initial step, let's change <code>lib/infra-stack.ts</code> file,</p>\n<pre><code class=\"hljs ts language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Stack</span>, <span class=\"hljs-title class_\">StackProps</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;aws-cdk-lib&quot;</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Construct</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;constructs&quot;</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">InfraStack</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Stack</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">scope: Construct, id: <span class=\"hljs-built_in\">string</span>, props?: StackProps</span>) {\n    <span class=\"hljs-variable language_\">super</span>(scope, id, {\n      <span class=\"hljs-attr\">env</span>: {\n        <span class=\"hljs-attr\">account</span>: process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">AWS_ACCOUNT_ID</span>,\n        <span class=\"hljs-attr\">region</span>: process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">AWS_DEFAULT_REGION</span>\n      }\n    })\n  }\n}\n</code></pre>\n<p>Here we are initializing the stack and setting the <code>account</code> and <code>region</code> from the environment variables.\nHaving the <code>account</code> and <code>region</code> is required to deploy the stack.</p>\n<h4 id=\"definingthevpc\">Defining the VPC</h4>\n<p>Let's start by creating a VPC for our application. All other resources will be created inside this VPC.</p>\n<pre><code class=\"hljs ts language-ts\"><span class=\"hljs-keyword\">const</span> vpc = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Vpc</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">&quot;AppVPC&quot;</span>, {\n  <span class=\"hljs-attr\">natGateways</span>: <span class=\"hljs-number\">0</span>\n})\n</code></pre>\n<h4 id=\"definingtheecscluster\">Defining the ECS cluster</h4>\n<p>Now we have to define an ECS cluster that contains all resources related to our ECS.</p>\n<pre><code class=\"hljs ts language-ts\"><span class=\"hljs-keyword\">const</span> cluster = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cluster</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">&quot;Cluster&quot;</span>, { vpc })\n</code></pre>\n<h4 id=\"definingapptask\">Defining app task</h4>\n<p>Before defining the task, we have to define a role for the task.\nThis role has to be based on the <code>ecs-tasks.amazonaws.com</code> role.</p>\n<pre><code class=\"hljs ts language-ts\"><span class=\"hljs-keyword\">const</span> taskRole = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Role</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">&quot;AppRole&quot;</span>, {\n  <span class=\"hljs-attr\">assumedBy</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ServicePrincipal</span>(<span class=\"hljs-string\">&quot;ecs-tasks.amazonaws.com&quot;</span>)\n})\n</code></pre>\n<p>Now we have to add required permissions to the role,\nThese permissions could change based on the requirements of the project.\nFor this project, we are going to add permissions for <code>log</code> and <code>CloudWatch</code>.</p>\n<pre><code class=\"hljs ts language-ts\">taskRole.<span class=\"hljs-title function_\">addToPolicy</span>(\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PolicyStatement</span>({\n    <span class=\"hljs-attr\">resources</span>: [<span class=\"hljs-string\">&quot;*&quot;</span>],\n    <span class=\"hljs-attr\">actions</span>: [<span class=\"hljs-string\">&quot;logs:*&quot;</span>, <span class=\"hljs-string\">&quot;cloudwatch:*&quot;</span>]\n  })\n)\n</code></pre>\n<p>Now we are ready to define the task. The task is the basic unit that runs on the actual container. As we are targeting EC2, we have to define the <code>compatibility</code> as <code>EC2</code>. And <code>obtainExecutionRole</code> will create the execution role for this task if it does not exist.</p>\n<pre><code class=\"hljs ts language-ts\"><span class=\"hljs-keyword\">const</span> taskDefinition = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TaskDefinition</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">&quot;AppTask&quot;</span>, {\n  taskRole,\n  <span class=\"hljs-attr\">compatibility</span>: <span class=\"hljs-title class_\">Compatibility</span>.<span class=\"hljs-property\">EC2</span>\n})\ntaskDefinition.<span class=\"hljs-title function_\">obtainExecutionRole</span>()\n</code></pre>\n<h4 id=\"definingtheautoscalinggroup\">Defining the auto-scaling group</h4>\n<p>Now we have to define an auto-scaling group that will handle the\ncreation and destruction of the EC2 instances. based on the\nrequirements of the capacity provider which will be defined later.\nHere I am using a <code>t3.nano</code> instance type, this can be changed based on the requirements. And I am setting the <code>desiredCapacity</code> to <code>0</code> so that no instances will be created at the beginning.</p>\n<pre><code class=\"hljs ts language-ts\"><span class=\"hljs-keyword\">const</span> asg = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AutoScalingGroup</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">&quot;ASG&quot;</span>, {\n  <span class=\"hljs-attr\">instanceType</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InstanceType</span>(<span class=\"hljs-string\">&quot;t3.nano&quot;</span>),\n  <span class=\"hljs-attr\">machineImage</span>: <span class=\"hljs-title class_\">EcsOptimizedImage</span>.<span class=\"hljs-title function_\">amazonLinux2</span>(),\n  <span class=\"hljs-attr\">associatePublicIpAddress</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">maxCapacity</span>: <span class=\"hljs-number\">3</span>,\n  <span class=\"hljs-attr\">desiredCapacity</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">minCapacity</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">vpc</span>: vpc,\n  <span class=\"hljs-attr\">vpcSubnets</span>: { <span class=\"hljs-attr\">subnetType</span>: <span class=\"hljs-title class_\">SubnetType</span>.<span class=\"hljs-property\">PUBLIC</span> },\n  <span class=\"hljs-attr\">newInstancesProtectedFromScaleIn</span>: <span class=\"hljs-literal\">false</span>\n})\n</code></pre>\n<h4 id=\"definingthecapacityprovider\">Defining the capacity provider</h4>\n<p>We are going to use the capacity provider to connect the auto-scaling group and the ECS cluster. This will handle all the scaling scenarios. I am setting the <code>enableManagedScaling</code> to <code>true</code> so that the capacity provider will handle the scaling of the instances. And I am setting the <code>targetCapacityPercent</code> to <code>100</code> so that the capacity provider will always try to keep the instances at 100% capacity and will not create additional instances. It's also important to note, by setting the <code>enableManagedTerminationProtection</code> to <code>false</code> we are allowing the capacity provider to terminate the instances if it is required.</p>\n<pre><code class=\"hljs ts language-ts\"><span class=\"hljs-keyword\">const</span> capacityProvider = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AsgCapacityProvider</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">&quot;EC2CapacityProvider&quot;</span>, {\n  <span class=\"hljs-attr\">autoScalingGroup</span>: asg,\n  <span class=\"hljs-attr\">enableManagedScaling</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">enableManagedTerminationProtection</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">targetCapacityPercent</span>: <span class=\"hljs-number\">100</span>\n})\n\ncluster.<span class=\"hljs-title function_\">addAsgCapacityProvider</span>(capacityProvider)\n</code></pre>\n<h4 id=\"definingtheappservice\">Defining the app service</h4>\n<p>Now we are ready to define the service which will contain the task. I am setting the <code>minHealthyPercent</code> to <code>0</code> so that the service will not wait for the instances to be healthy before starting the deployment. And I am setting the <code>capacityProviderStrategies</code> to use the capacity provider which we defined earlier.</p>\n<pre><code class=\"hljs ts language-ts\"><span class=\"hljs-keyword\">const</span> service = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Ec2Service</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">&quot;AppService&quot;</span>, {\n  taskDefinition,\n  cluster,\n  <span class=\"hljs-attr\">desiredCount</span>: <span class=\"hljs-number\">1</span>,\n  <span class=\"hljs-attr\">minHealthyPercent</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">capacityProviderStrategies</span>: [\n    {\n      <span class=\"hljs-attr\">capacityProvider</span>: capacityProvider.<span class=\"hljs-property\">capacityProviderName</span>,\n      <span class=\"hljs-attr\">weight</span>: <span class=\"hljs-number\">1</span>,\n      <span class=\"hljs-attr\">base</span>: <span class=\"hljs-number\">0</span>\n    }\n  ]\n})\n</code></pre>\n<h4 id=\"definingthecontainer\">Defining the container</h4>\n<p>Now we are ready to define the container where the task will be running, Here I am\nusing <code>ContainerImage.fromAsset</code> to build the image from the local directory. CDK will\nbuild the image locally and push it to ECR. I am also using <code>awsLogs</code> driver to push the logs to CloudWatch. And I am setting the <code>memoryReservationMiB</code> to <code>200</code> so that the container will have a minimum of 200MB of memory. This amount can be changed based on the\nrequirements of the application. This value will be taken into consideration when scaling the app. And I am also mapping port <code>3000</code> of the container to port <code>3000</code> of the host. As NextJS is by default running on port <code>3000</code>.</p>\n<pre><code class=\"hljs ts language-ts\"><span class=\"hljs-keyword\">const</span> container = taskDefinition.<span class=\"hljs-title function_\">addContainer</span>(<span class=\"hljs-string\">&quot;AppContainer&quot;</span>, {\n  <span class=\"hljs-attr\">linuxParameters</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinuxParameters</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">&quot;AppLinuxParams&quot;</span>),\n  <span class=\"hljs-attr\">image</span>: <span class=\"hljs-title class_\">ContainerImage</span>.<span class=\"hljs-title function_\">fromAsset</span>(<span class=\"hljs-string\">&quot;../app&quot;</span>),\n  <span class=\"hljs-attr\">logging</span>: <span class=\"hljs-title class_\">LogDriver</span>.<span class=\"hljs-title function_\">awsLogs</span>({\n    <span class=\"hljs-attr\">streamPrefix</span>: <span class=\"hljs-string\">&quot;app&quot;</span>,\n    <span class=\"hljs-attr\">logRetention</span>: <span class=\"hljs-title class_\">RetentionDays</span>.<span class=\"hljs-property\">ONE_WEEK</span>\n  }),\n  <span class=\"hljs-attr\">environment</span>: {\n    <span class=\"hljs-attr\">NODE_ENV</span>: <span class=\"hljs-string\">&quot;production&quot;</span>\n  },\n  <span class=\"hljs-attr\">memoryReservationMiB</span>: <span class=\"hljs-number\">200</span>\n})\n\ncontainer.<span class=\"hljs-title function_\">addPortMappings</span>({\n  <span class=\"hljs-attr\">containerPort</span>: <span class=\"hljs-number\">3000</span>,\n  <span class=\"hljs-attr\">hostPort</span>: <span class=\"hljs-number\">3000</span>,\n  <span class=\"hljs-attr\">protocol</span>: <span class=\"hljs-title class_\">ECSProtocol</span>.<span class=\"hljs-property\">TCP</span>\n})\n</code></pre>\n<h3 id=\"httpcertificate\">HTTP certificate</h3>\n<p>Now we have to have a certificate for the domain which we are going to use. This certificate will be used by the load balancer to serve the traffic over HTTPS. Make sure you create this certificate in the <code>us-east-1</code> region. This is a requirement for the load balancer.</p>\n<p>As we are not in the <code>us-east-1</code> region, we have to import the certificate using the <code>Certificate.fromCertificateArn</code> method. You can copy the ARN of the certificate from the AWS console. I am setting the <code>APP_CERTIFICATE_ARN</code> environment variable to the ARN of the certificate.</p>\n<pre><code class=\"hljs ts language-ts\"><span class=\"hljs-keyword\">const</span> domainCertificate = <span class=\"hljs-title class_\">Certificate</span>.<span class=\"hljs-title function_\">fromCertificateArn</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">&quot;AppCertificate&quot;</span>, process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">APP_CERTIFICATE_ARN</span>!)\n</code></pre>\n<h3 id=\"definingtheloadbalancer\">Defining the load balancer</h3>\n<p>Now we are ready to define the load balancer,</p>\n<pre><code class=\"hljs ts language-ts\"><span class=\"hljs-keyword\">const</span> loadBalancer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ApplicationLoadBalancer</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">&quot;AppLoadBalancer&quot;</span>, {\n  vpc,\n  <span class=\"hljs-attr\">internetFacing</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">vpcSubnets</span>: { <span class=\"hljs-attr\">subnetType</span>: <span class=\"hljs-title class_\">SubnetType</span>.<span class=\"hljs-property\">PUBLIC</span> }\n})\n</code></pre>\n<h5 id=\"redirectinghttptohttps\">Redirecting HTTP to HTTPS</h5>\n<p>We will redirect the HTTP traffic to HTTPS. This is done by adding a redirect rule to the load balancer. This will redirect all the traffic coming from port <code>80</code> to port <code>443</code> over HTTPS.</p>\n<pre><code class=\"hljs ts language-ts\">loadBalancer.<span class=\"hljs-title function_\">addRedirect</span>({\n  <span class=\"hljs-attr\">sourcePort</span>: <span class=\"hljs-number\">80</span>,\n  <span class=\"hljs-attr\">sourceProtocol</span>: <span class=\"hljs-title class_\">ApplicationProtocol</span>.<span class=\"hljs-property\">HTTP</span>,\n  <span class=\"hljs-attr\">targetPort</span>: <span class=\"hljs-number\">443</span>,\n  <span class=\"hljs-attr\">targetProtocol</span>: <span class=\"hljs-title class_\">ApplicationProtocol</span>.<span class=\"hljs-property\">HTTPS</span>\n})\n</code></pre>\n<h5 id=\"allowegresstraffic\">Allow egress traffic</h5>\n<p>We have to allow the load balancer to make requests to the internet. This is done by adding a security group rule to the load balancer.</p>\n<pre><code class=\"hljs ts language-ts\">loadBalancer.<span class=\"hljs-property\">connections</span>.<span class=\"hljs-title function_\">allowToAnyIpv4</span>(<span class=\"hljs-title class_\">Port</span>.<span class=\"hljs-title function_\">allTcp</span>(), <span class=\"hljs-string\">&quot;All Out&quot;</span>)\n</code></pre>\n<h5 id=\"connectingtheloadbalancertotheapp\">Connecting the load balancer to the app</h5>\n<p>Now we are ready to connect the load balancer to the app.\nFirst, we will create a listener on port 443 and add the certificate which we created earlier.\nThen we can add the app service as a target to the listener.</p>\n<p>Ans we also have to make sure the load balancer can be accessed from the internet. This can be done\nusing <code>allowFromAnyIpv4</code> method for ports <code>80</code> and <code>443</code>.</p>\n<p>Finally, we will allow the load balancer to make requests to the app on port <code>3000</code>.</p>\n<pre><code class=\"hljs ts language-ts\"><span class=\"hljs-keyword\">const</span> listener = loadBalancer.<span class=\"hljs-title function_\">addListener</span>(<span class=\"hljs-string\">&quot;AutomateListener&quot;</span>, {\n  <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">443</span>,\n  <span class=\"hljs-attr\">certificates</span>: [domainCertificate],\n  <span class=\"hljs-attr\">protocol</span>: <span class=\"hljs-title class_\">ApplicationProtocol</span>.<span class=\"hljs-property\">HTTPS</span>\n})\n\nlistener.<span class=\"hljs-title function_\">addTargets</span>(<span class=\"hljs-string\">&quot;AppTarget&quot;</span>, {\n  <span class=\"hljs-attr\">healthCheck</span>: {\n    <span class=\"hljs-attr\">enabled</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">protocol</span>: <span class=\"hljs-title class_\">Protocol</span>.<span class=\"hljs-property\">HTTP</span>\n  },\n  <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">3000</span>,\n  <span class=\"hljs-attr\">deregistrationDelay</span>: <span class=\"hljs-title class_\">Duration</span>.<span class=\"hljs-title function_\">seconds</span>(<span class=\"hljs-number\">3</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>,\n  <span class=\"hljs-attr\">protocol</span>: <span class=\"hljs-title class_\">ApplicationProtocol</span>.<span class=\"hljs-property\">HTTP</span>,\n  <span class=\"hljs-attr\">targets</span>: [service]\n})\n\nloadBalancer.<span class=\"hljs-property\">connections</span>.<span class=\"hljs-title function_\">allowFromAnyIpv4</span>(<span class=\"hljs-title class_\">Port</span>.<span class=\"hljs-title function_\">tcp</span>(<span class=\"hljs-number\">80</span>), <span class=\"hljs-string\">&quot;Ingress HTTP internet&quot;</span>)\nloadBalancer.<span class=\"hljs-property\">connections</span>.<span class=\"hljs-title function_\">allowFromAnyIpv4</span>(<span class=\"hljs-title class_\">Port</span>.<span class=\"hljs-title function_\">tcp</span>(<span class=\"hljs-number\">443</span>), <span class=\"hljs-string\">&quot;Ingress HTTPS internet&quot;</span>)\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> subnet <span class=\"hljs-keyword\">of</span> vpc.<span class=\"hljs-property\">publicSubnets</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>) {\n  asg.<span class=\"hljs-property\">connections</span>.<span class=\"hljs-title function_\">allowFrom</span>(<span class=\"hljs-title class_\">Peer</span>.<span class=\"hljs-title function_\">ipv4</span>(subnet.<span class=\"hljs-property\">ipv4CidrBlock</span>), <span class=\"hljs-title class_\">Port</span>.<span class=\"hljs-title function_\">tcp</span>(<span class=\"hljs-number\">3000</span>), <span class=\"hljs-string\">&quot;Ingress from ALB to App&quot;</span>)\n}\n</code></pre>\n<h3 id=\"hostedzoneandsubdomain\">Hosted zone and subdomain</h3>\n<p>As my domain is handled by AWS, I will add the subdomain to the hosted zone also here, If this is not the case for you, you can skip this step and directly point the domain to the load balancer's public IP which you can find after the deployment is done in the AWS console.</p>\n<pre><code class=\"hljs ts language-ts\"><span class=\"hljs-keyword\">const</span> hostedZone = <span class=\"hljs-title class_\">PublicHostedZone</span>.<span class=\"hljs-title function_\">fromLookup</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">&quot;HostedZone&quot;</span>, {\n  <span class=\"hljs-attr\">domainName</span>: <span class=\"hljs-string\">&quot;&lt;some-domain&gt;.com&quot;</span>\n})\n\n<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ARecord</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">&quot;AppARecord&quot;</span>, {\n  <span class=\"hljs-attr\">zone</span>: hostedZone,\n  <span class=\"hljs-attr\">target</span>: <span class=\"hljs-title class_\">RecordTarget</span>.<span class=\"hljs-title function_\">fromAlias</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LoadBalancerTarget</span>(loadBalancer <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>)),\n  <span class=\"hljs-attr\">recordName</span>: <span class=\"hljs-string\">&quot;app&quot;</span>\n})\n</code></pre>\n<h3 id=\"deployingtheapp\">Deploying the app,</h3>\n<p>Now our infrastructure definition is ready to go.\nBefore deploying, we have to bootstrap the application, Before that, we have to make sure we have\nthe AWS credentials are set in the environment variables. And also make sure the <code>AWS_ACCOUNT_ID</code>\nand <code>APP_CERTIFICATE_ARN</code> environment variables are set.</p>\n<pre><code class=\"hljs sh language-sh\"><span class=\"hljs-comment\"># For bash:</span>\n<span class=\"hljs-built_in\">export</span> AWS_ACCOUNT_ID=<span class=\"hljs-string\">&quot;&lt;AWS_ACCOUNT_ID&gt;&quot;</span>\n<span class=\"hljs-built_in\">export</span> AWS_ACCESS_KEY_ID=<span class=\"hljs-string\">&quot;&lt;AWS_ACCESS_KEY_ID&gt;&quot;</span>\n<span class=\"hljs-built_in\">export</span> AWS_SECRET_ACCESS_KEY=<span class=\"hljs-string\">&quot;&lt;AWS_SECRET_ACCESS_KEY&gt;&quot;</span>\n<span class=\"hljs-built_in\">export</span> AWS_DEFAULT_REGION=<span class=\"hljs-string\">&quot;&lt;REGION&gt;&quot;</span>\n<span class=\"hljs-built_in\">export</span> APP_CERTIFICATE_ARN=<span class=\"hljs-string\">&quot;arn:aws:acm:...&quot;</span>\n</code></pre>\n<p>Now we can run the below command inside the <code>infra</code> folder to bootstrap the app,</p>\n<pre><code class=\"hljs sh language-sh\">npx aws-cdk bootstrap\n</code></pre>\n<p><img src=\"https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/cdk-bootstrap-result.jpg\" /></p>\n<p>And finally, we can deploy the app using the below command, This will take some time because it has to build the app image and push that to the ECR registry. I am doing this completely from the local machine but the steps are the same if you are using a CI/CD pipeline.</p>\n<p>Also, make sure Docker is running on your machine as the CDK will use the local Docker daemon to build the image.</p>\n<pre><code class=\"hljs sh language-sh\">npx aws-cdk deploy\n</code></pre>\n<p>Once the deployment is complete, It should return an output like below,</p>\n<p><img src=\"https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/cdk-deploy-result.png\" /></p>\n<p>Now you should see the stack is created in the Cloudfomration console.</p>\n<p><img src=\"https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/cloudformation-console.png\" /></p>\n<h3 id=\"testingtheapp\">Testing the app</h3>\n<p>Now we can test the app by visiting the domain which you used.</p>\n<p><img src=\"https://rusith.me/post-data/2023-02-15-deploying-react-app-on-ecs/app.png\" /></p>\n<p>Now, If you increase the number of desired tasks for the service, The auto-scaling group will automatically facilitate the scaling by creating new instances.</p>\n<h3 id=\"troubleshooting\">Troubleshooting</h3>\n<p>If you get the error <code>The runtime parameter of python3.6 is no longer supported for creating or updating AWS Lambda functions. We recommend you use the new runtime (python3.9)</code>,</p>\n<p>Remove the <code>aws-cdk</code> package from the <code>package.json</code> file set the version for the package <code>aws-cdk-lib</code> to <code>^2.61.1</code>, install packages and run deploy again.</p>\n<h3 id=\"sourcecode\">Source code</h3>\n<p>You can find the source code for this blog post <a href=\"https://github.com/rusith/2023-02-15-deploying-react-app-on-ecs\">here</a></p>"},"page":"Post","topTags":["programming","aws","web","machineLearning","react","javascript","dataScience","typescript","r","csharp"],"relatedPosts":[{"title":"Testing Redux Connected React Components Using Jest","tags":["programming","javascript","react","redux","testing","jest"],"fullUrl":"https://rusith.me/blog/testing-react-redux-connected-components-using-jest","date":"Mon, Apr 27, 2020","description":"Testing React components connected to a Redux store using Jest and React Testing Library.","banner":"/post-data/2020-04-27-testing-redux-connect/banner.png"},{"title":"Running a Nuget Feed on S3 with Automated Deployments","tags":["programming","dotnet","s3","aws","nuget"],"fullUrl":"https://rusith.me/blog/nuget-feed-on-s3","date":"Sat, Nov 2, 2019","description":"There are many ways of creating a Nuget feed. but did you know that you can run a Nuget feed on S3 without any computing infrastructure? In this post, I will show you how you can create a Nuget feed on S3 using Sleet and automate the deployment process for packages.","banner":"/post-data/2019-11-03-nuget-feed-s3/banner.png"},{"title":"Deploying a Website on S3 With SSL, Continuous Integration","tags":["aws","programming","web"],"fullUrl":"https://rusith.me/blog/building-a-website-on-s3","date":"Mon, Aug 5, 2019","description":"In this post, I am creating a website and host it on S3 and setup a continuous integration pipeline setup using Gitlab","banner":"/post-data/2019-08-14-building-a-website-on-s3/banner.png"}]},"__N_SSG":true}